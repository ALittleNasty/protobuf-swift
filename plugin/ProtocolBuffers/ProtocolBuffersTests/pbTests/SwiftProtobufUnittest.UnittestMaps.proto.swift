// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "unittest_maps.proto"
// Syntax "Proto2"

import Foundation
import ProtocolBuffers

public struct SwiftProtobufUnittest { }

public func == (lhs: SwiftProtobufUnittest.MapMessageValue, rhs: SwiftProtobufUnittest.MapMessageValue) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasValueInMapMessage == rhs.hasValueInMapMessage) && (!lhs.hasValueInMapMessage || lhs.valueInMapMessage == rhs.valueInMapMessage)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SwiftProtobufUnittest.MessageContainsMap, rhs: SwiftProtobufUnittest.MessageContainsMap) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMapInt32Int32 == rhs.hasMapInt32Int32) && (!lhs.hasMapInt32Int32 || lhs.mapInt32Int32 == rhs.mapInt32Int32)
  fieldCheck = fieldCheck && (lhs.hasMapInt64Int64 == rhs.hasMapInt64Int64) && (!lhs.hasMapInt64Int64 || lhs.mapInt64Int64 == rhs.mapInt64Int64)
  fieldCheck = fieldCheck && (lhs.hasMapStringString == rhs.hasMapStringString) && (!lhs.hasMapStringString || lhs.mapStringString == rhs.mapStringString)
  fieldCheck = fieldCheck && (lhs.hasMapStringBytes == rhs.hasMapStringBytes) && (!lhs.hasMapStringBytes || lhs.mapStringBytes == rhs.mapStringBytes)
  fieldCheck = fieldCheck && (lhs.hasMapStringMessage == rhs.hasMapStringMessage) && (!lhs.hasMapStringMessage || lhs.mapStringMessage == rhs.mapStringMessage)
  fieldCheck = fieldCheck && (lhs.hasMapInt32Enum == rhs.hasMapInt32Enum) && (!lhs.hasMapInt32Enum || lhs.mapInt32Enum == rhs.mapInt32Enum)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry, rhs: SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry, rhs: SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry, rhs: SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry, rhs: SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry, rhs: SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry, rhs: SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public extension SwiftProtobufUnittest {
  public struct UnittestMapsRoot {
    public static var sharedInstance : UnittestMapsRoot {
     struct Static {
         static let instance : UnittestMapsRoot = UnittestMapsRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }

  final public class MapMessageValue : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasValueInMapMessage:Bool = false
    public private(set) var valueInMapMessage:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasValueInMapMessage {
        try output.writeInt32(1, value:valueInMapMessage)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasValueInMapMessage {
        serialize_size += valueInMapMessage.computeInt32Size(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<SwiftProtobufUnittest.MapMessageValue> {
      var mergedArray = Array<SwiftProtobufUnittest.MapMessageValue>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MapMessageValue? {
      return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> SwiftProtobufUnittest.MapMessageValue {
      return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFromData(data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MapMessageValue {
      return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MapMessageValue {
      return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MapMessageValue {
      return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MapMessageValue {
      return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MapMessageValue {
      return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> SwiftProtobufUnittest.MapMessageValue.Builder {
      return SwiftProtobufUnittest.MapMessageValue.classBuilder() as! SwiftProtobufUnittest.MapMessageValue.Builder
    }
    public func getBuilder() -> SwiftProtobufUnittest.MapMessageValue.Builder {
      return classBuilder() as! SwiftProtobufUnittest.MapMessageValue.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return SwiftProtobufUnittest.MapMessageValue.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return SwiftProtobufUnittest.MapMessageValue.Builder()
    }
    public func toBuilder() throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
      return try SwiftProtobufUnittest.MapMessageValue.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MapMessageValue) throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
      return try SwiftProtobufUnittest.MapMessageValue.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasValueInMapMessage {
        jsonMap["valueInMapMessage"] = NSNumber(int:valueInMapMessage)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MapMessageValue {
      return try SwiftProtobufUnittest.MapMessageValue.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> SwiftProtobufUnittest.MapMessageValue {
      return try SwiftProtobufUnittest.MapMessageValue.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasValueInMapMessage {
        output += "\(indent) valueInMapMessage: \(valueInMapMessage) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasValueInMapMessage {
               hashCode = (hashCode &* 31) &+ valueInMapMessage.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "SwiftProtobufUnittest.MapMessageValue"
    }
    override public func className() -> String {
        return "SwiftProtobufUnittest.MapMessageValue"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return SwiftProtobufUnittest.MapMessageValue.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:SwiftProtobufUnittest.MapMessageValue = SwiftProtobufUnittest.MapMessageValue()
      public func getMessage() -> SwiftProtobufUnittest.MapMessageValue {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasValueInMapMessage:Bool {
           get {
                return builderResult.hasValueInMapMessage
           }
      }
      public var valueInMapMessage:Int32 {
           get {
                return builderResult.valueInMapMessage
           }
           set (value) {
               builderResult.hasValueInMapMessage = true
               builderResult.valueInMapMessage = value
           }
      }
      public func setValueInMapMessage(value:Int32) -> SwiftProtobufUnittest.MapMessageValue.Builder {
        self.valueInMapMessage = value
        return self
      }
      public func clearValueInMapMessage() -> SwiftProtobufUnittest.MapMessageValue.Builder{
           builderResult.hasValueInMapMessage = false
           builderResult.valueInMapMessage = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> SwiftProtobufUnittest.MapMessageValue.Builder {
        builderResult = SwiftProtobufUnittest.MapMessageValue()
        return self
      }
      override public func clone() throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
        return try SwiftProtobufUnittest.MapMessageValue.builderWithPrototype(builderResult)
      }
      override public func build() throws -> SwiftProtobufUnittest.MapMessageValue {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> SwiftProtobufUnittest.MapMessageValue {
        let returnMe:SwiftProtobufUnittest.MapMessageValue = builderResult
        return returnMe
      }
      public func mergeFrom(other:SwiftProtobufUnittest.MapMessageValue) throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
        if other == SwiftProtobufUnittest.MapMessageValue() {
         return self
        }
        if other.hasValueInMapMessage {
             valueInMapMessage = other.valueInMapMessage
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            valueInMapMessage = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
        let resultDecodedBuilder = SwiftProtobufUnittest.MapMessageValue.Builder()
        if let jsonValueValueInMapMessage = jsonMap["valueInMapMessage"] as? NSNumber {
          resultDecodedBuilder.valueInMapMessage = jsonValueValueInMapMessage.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> SwiftProtobufUnittest.MapMessageValue.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try SwiftProtobufUnittest.MapMessageValue.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class MessageContainsMap : GeneratedMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      final public class MapInt32Int32Entry : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasKey:Bool = false
        public private(set) var key:Int32 = Int32(0)

        public private(set) var hasValue:Bool = false
        public private(set) var value:Int32 = Int32(0)

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasKey {
            try output.writeInt32(1, value:key)
          }
          if hasValue {
            try output.writeInt32(2, value:value)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKey {
            serialize_size += key.computeInt32Size(1)
          }
          if hasValue {
            serialize_size += value.computeInt32Size(2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry> {
          var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry? {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFromData(data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder
        }
        public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
          return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder()
        }
        public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if hasKey {
            jsonMap["key"] = NSNumber(int:key)
          }
          if hasValue {
            jsonMap["value"] = NSNumber(int:value)
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasValue {
            output += "\(indent) value: \(value) \n"
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                   hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry"
        }
        override public func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry = SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry()
          public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:Int32 {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          public func setKey(value:Int32) -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            self.key = value
            return self
          }
          public func clearKey() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder{
               builderResult.hasKey = false
               builderResult.key = Int32(0)
               return self
          }
          public var hasValue:Bool {
               get {
                    return builderResult.hasValue
               }
          }
          public var value:Int32 {
               get {
                    return builderResult.value
               }
               set (value) {
                   builderResult.hasValue = true
                   builderResult.value = value
               }
          }
          public func setValue(value:Int32) -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            self.value = value
            return self
          }
          public func clearValue() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder{
               builderResult.hasValue = false
               builderResult.value = Int32(0)
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            builderResult = SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry()
            return self
          }
          override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.builderWithPrototype(builderResult)
          }
          override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry {
            let returnMe:SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry = builderResult
            return returnMe
          }
          public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            if other == SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry() {
             return self
            }
            if other.hasKey {
                 key = other.key
            }
            if other.hasValue {
                 value = other.value
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                key = try input.readInt32()

              case 16 :
                value = try input.readInt32()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder()
            if let jsonValueKey = jsonMap["key"] as? NSNumber {
              resultDecodedBuilder.key = jsonValueKey.intValue
            }
            if let jsonValueValue = jsonMap["value"] as? NSNumber {
              resultDecodedBuilder.value = jsonValueValue.intValue
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder {
            let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
            }
            return try SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final public class MapInt64Int64Entry : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasKey:Bool = false
        public private(set) var key:Int64 = Int64(0)

        public private(set) var hasValue:Bool = false
        public private(set) var value:Int64 = Int64(0)

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasKey {
            try output.writeInt64(1, value:key)
          }
          if hasValue {
            try output.writeInt64(2, value:value)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKey {
            serialize_size += key.computeInt64Size(1)
          }
          if hasValue {
            serialize_size += value.computeInt64Size(2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry> {
          var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry? {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFromData(data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder
        }
        public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
          return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder()
        }
        public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if hasKey {
            jsonMap["key"] = "\(key)"
          }
          if hasValue {
            jsonMap["value"] = "\(value)"
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasValue {
            output += "\(indent) value: \(value) \n"
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                   hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry"
        }
        override public func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry = SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry()
          public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:Int64 {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          public func setKey(value:Int64) -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            self.key = value
            return self
          }
          public func clearKey() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder{
               builderResult.hasKey = false
               builderResult.key = Int64(0)
               return self
          }
          public var hasValue:Bool {
               get {
                    return builderResult.hasValue
               }
          }
          public var value:Int64 {
               get {
                    return builderResult.value
               }
               set (value) {
                   builderResult.hasValue = true
                   builderResult.value = value
               }
          }
          public func setValue(value:Int64) -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            self.value = value
            return self
          }
          public func clearValue() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder{
               builderResult.hasValue = false
               builderResult.value = Int64(0)
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            builderResult = SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry()
            return self
          }
          override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.builderWithPrototype(builderResult)
          }
          override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry {
            let returnMe:SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry = builderResult
            return returnMe
          }
          public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            if other == SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry() {
             return self
            }
            if other.hasKey {
                 key = other.key
            }
            if other.hasValue {
                 value = other.value
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                key = try input.readInt64()

              case 16 :
                value = try input.readInt64()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
              resultDecodedBuilder.key = Int64(jsonValueKey)!
            }
            if let jsonValueValue = jsonMap["value"] as? String {
              resultDecodedBuilder.value = Int64(jsonValueValue)!
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder {
            let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
            }
            return try SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final public class MapStringStringEntry : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasKey:Bool = false
        public private(set) var key:String = ""

        public private(set) var hasValue:Bool = false
        public private(set) var value:String = ""

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasKey {
            try output.writeString(1, value:key)
          }
          if hasValue {
            try output.writeString(2, value:value)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKey {
            serialize_size += key.computeStringSize(1)
          }
          if hasValue {
            serialize_size += value.computeStringSize(2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry> {
          var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry? {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFromData(data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder
        }
        public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
          return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder()
        }
        public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if hasKey {
            jsonMap["key"] = key
          }
          if hasValue {
            jsonMap["value"] = value
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasValue {
            output += "\(indent) value: \(value) \n"
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                   hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry"
        }
        override public func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry = SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry()
          public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:String {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          public func setKey(value:String) -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            self.key = value
            return self
          }
          public func clearKey() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder{
               builderResult.hasKey = false
               builderResult.key = ""
               return self
          }
          public var hasValue:Bool {
               get {
                    return builderResult.hasValue
               }
          }
          public var value:String {
               get {
                    return builderResult.value
               }
               set (value) {
                   builderResult.hasValue = true
                   builderResult.value = value
               }
          }
          public func setValue(value:String) -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            self.value = value
            return self
          }
          public func clearValue() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder{
               builderResult.hasValue = false
               builderResult.value = ""
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            builderResult = SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry()
            return self
          }
          override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.builderWithPrototype(builderResult)
          }
          override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry {
            let returnMe:SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry = builderResult
            return returnMe
          }
          public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            if other == SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry() {
             return self
            }
            if other.hasKey {
                 key = other.key
            }
            if other.hasValue {
                 value = other.value
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10 :
                key = try input.readString()

              case 18 :
                value = try input.readString()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
              resultDecodedBuilder.key = jsonValueKey
            }
            if let jsonValueValue = jsonMap["value"] as? String {
              resultDecodedBuilder.value = jsonValueValue
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder {
            let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
            }
            return try SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final public class MapStringBytesEntry : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasKey:Bool = false
        public private(set) var key:String = ""

        public private(set) var hasValue:Bool = false
        public private(set) var value:NSData = NSData()

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasKey {
            try output.writeString(1, value:key)
          }
          if hasValue {
            try output.writeData(2, value:value)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKey {
            serialize_size += key.computeStringSize(1)
          }
          if hasValue {
            serialize_size += value.computeDataSize(2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry> {
          var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry? {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFromData(data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder
        }
        public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
          return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder()
        }
        public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if hasKey {
            jsonMap["key"] = key
          }
          if hasValue {
            jsonMap["value"] = value.base64EncodedStringWithOptions(NSDataBase64EncodingOptions(rawValue: 0))
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasValue {
            output += "\(indent) value: \(value) \n"
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                   hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry"
        }
        override public func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry = SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry()
          public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:String {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          public func setKey(value:String) -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            self.key = value
            return self
          }
          public func clearKey() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder{
               builderResult.hasKey = false
               builderResult.key = ""
               return self
          }
          public var hasValue:Bool {
               get {
                    return builderResult.hasValue
               }
          }
          public var value:NSData {
               get {
                    return builderResult.value
               }
               set (value) {
                   builderResult.hasValue = true
                   builderResult.value = value
               }
          }
          public func setValue(value:NSData) -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            self.value = value
            return self
          }
          public func clearValue() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder{
               builderResult.hasValue = false
               builderResult.value = NSData()
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            builderResult = SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry()
            return self
          }
          override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.builderWithPrototype(builderResult)
          }
          override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry {
            let returnMe:SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry = builderResult
            return returnMe
          }
          public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            if other == SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry() {
             return self
            }
            if other.hasKey {
                 key = other.key
            }
            if other.hasValue {
                 value = other.value
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10 :
                key = try input.readString()

              case 18 :
                value = try input.readData()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
              resultDecodedBuilder.key = jsonValueKey
            }
            if let jsonValueValue = jsonMap["value"] as? String {
              resultDecodedBuilder.value = NSData(base64EncodedString:jsonValueValue, options: NSDataBase64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder {
            let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
            }
            return try SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final public class MapStringMessageEntry : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasKey:Bool = false
        public private(set) var key:String = ""

        public private(set) var hasValue:Bool = false
        public private(set) var value:SwiftProtobufUnittest.MapMessageValue!
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasKey {
            try output.writeString(1, value:key)
          }
          if hasValue {
            try output.writeMessage(2, value:value)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKey {
            serialize_size += key.computeStringSize(1)
          }
          if hasValue {
              if let varSizevalue = value?.computeMessageSize(2) {
                  serialize_size += varSizevalue
              }
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry> {
          var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry? {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFromData(data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder
        }
        public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
          return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder()
        }
        public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if hasKey {
            jsonMap["key"] = key
          }
          if hasValue {
            jsonMap["value"] = try value.encode()
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasValue {
            output += "\(indent) value {\n"
            if let outDescValue = value {
              output += try outDescValue.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                    if let hashValuevalue = value?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuevalue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry"
        }
        override public func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry = SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry()
          public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:String {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          public func setKey(value:String) -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            self.key = value
            return self
          }
          public func clearKey() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder{
               builderResult.hasKey = false
               builderResult.key = ""
               return self
          }
          public var hasValue:Bool {
               get {
                   return builderResult.hasValue
               }
          }
          public var value:SwiftProtobufUnittest.MapMessageValue! {
               get {
                   if valueBuilder_ != nil {
                      builderResult.value = valueBuilder_.getMessage()
                   }
                   return builderResult.value
               }
               set (value) {
                   builderResult.hasValue = true
                   builderResult.value = value
               }
          }
          private var valueBuilder_:SwiftProtobufUnittest.MapMessageValue.Builder! {
               didSet {
                  builderResult.hasValue = true
               }
          }
          public func getValueBuilder() -> SwiftProtobufUnittest.MapMessageValue.Builder {
            if valueBuilder_ == nil {
               valueBuilder_ = SwiftProtobufUnittest.MapMessageValue.Builder()
               builderResult.value = valueBuilder_.getMessage()
               if value != nil {
                  try! valueBuilder_.mergeFrom(value)
               }
            }
            return valueBuilder_
          }
          public func setValue(value:SwiftProtobufUnittest.MapMessageValue!) -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            self.value = value
            return self
          }
          public func mergeValue(value:SwiftProtobufUnittest.MapMessageValue) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            if builderResult.hasValue {
              builderResult.value = try SwiftProtobufUnittest.MapMessageValue.builderWithPrototype(builderResult.value).mergeFrom(value).buildPartial()
            } else {
              builderResult.value = value
            }
            builderResult.hasValue = true
            return self
          }
          public func clearValue() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            valueBuilder_ = nil
            builderResult.hasValue = false
            builderResult.value = nil
            return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            builderResult = SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry()
            return self
          }
          override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.builderWithPrototype(builderResult)
          }
          override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry {
            let returnMe:SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry = builderResult
            return returnMe
          }
          public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            if other == SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry() {
             return self
            }
            if other.hasKey {
                 key = other.key
            }
            if (other.hasValue) {
                try mergeValue(other.value)
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10 :
                key = try input.readString()

              case 18 :
                let subBuilder:SwiftProtobufUnittest.MapMessageValue.Builder = SwiftProtobufUnittest.MapMessageValue.Builder()
                if hasValue {
                  try subBuilder.mergeFrom(value)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                value = subBuilder.buildPartial()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
              resultDecodedBuilder.key = jsonValueKey
            }
            if let jsonValueValue = jsonMap["value"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.value = try SwiftProtobufUnittest.MapMessageValue.Builder.decodeToBuilder(jsonValueValue).build()

            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder {
            let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
            }
            return try SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      final public class MapInt32EnumEntry : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasKey:Bool = false
        public private(set) var key:Int32 = Int32(0)

        public private(set) var value:SwiftProtobufUnittest.MessageContainsMap.EnumMapValue = SwiftProtobufUnittest.MessageContainsMap.EnumMapValue.FirstValueEnum
        public private(set) var hasValue:Bool = false
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasKey {
            try output.writeInt32(1, value:key)
          }
          if hasValue {
            try output.writeEnum(2, value:value.rawValue)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasKey {
            serialize_size += key.computeInt32Size(1)
          }
          if (hasValue) {
            serialize_size += value.rawValue.computeEnumSize(2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry> {
          var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry? {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFromData(data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder
        }
        public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
          return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder()
        }
        public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if hasKey {
            jsonMap["key"] = NSNumber(int:key)
          }
          if hasValue {
            jsonMap["value"] = value.toString()
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
          return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if (hasValue) {
            output += "\(indent) value: \(value.description)\n"
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                   hashCode = (hashCode &* 31) &+ Int(value.rawValue)
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry"
        }
        override public func className() -> String {
            return "SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry = SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry()
          public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:Int32 {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          public func setKey(value:Int32) -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            self.key = value
            return self
          }
          public func clearKey() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder{
               builderResult.hasKey = false
               builderResult.key = Int32(0)
               return self
          }
            public var hasValue:Bool{
                get {
                    return builderResult.hasValue
                }
            }
            public var value:SwiftProtobufUnittest.MessageContainsMap.EnumMapValue {
                get {
                    return builderResult.value
                }
                set (value) {
                    builderResult.hasValue = true
                    builderResult.value = value
                }
            }
            public func setValue(value:SwiftProtobufUnittest.MessageContainsMap.EnumMapValue) -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
              self.value = value
              return self
            }
            public func clearValue() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
               builderResult.hasValue = false
               builderResult.value = .FirstValueEnum
               return self
            }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            builderResult = SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry()
            return self
          }
          override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.builderWithPrototype(builderResult)
          }
          override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry {
            let returnMe:SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry = builderResult
            return returnMe
          }
          public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            if other == SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry() {
             return self
            }
            if other.hasKey {
                 key = other.key
            }
            if other.hasValue {
                 value = other.value
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                key = try input.readInt32()

              case 16 :
                let valueIntvalue = try input.readEnum()
                if let enumsvalue = SwiftProtobufUnittest.MessageContainsMap.EnumMapValue(rawValue:valueIntvalue){
                     value = enumsvalue
                } else {
                     try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntvalue))
                }

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder()
            if let jsonValueKey = jsonMap["key"] as? NSNumber {
              resultDecodedBuilder.key = jsonValueKey.intValue
            }
            if let jsonValueValue = jsonMap["value"] as? String {
              resultDecodedBuilder.value = try SwiftProtobufUnittest.MessageContainsMap.EnumMapValue.fromString(jsonValueValue)
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder {
            let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
            }
            return try SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end



      //Enum type declaration start 

      public enum EnumMapValue:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case FirstValueEnum = 0
        case SecondValueEnum = 1
        public func toString() -> String {
          switch self {
          case .FirstValueEnum: return "FirstValueEnum"
          case .SecondValueEnum: return "SecondValueEnum"
          }
        }
        public static func fromString(str:String) throws -> SwiftProtobufUnittest.MessageContainsMap.EnumMapValue {
          switch str {
          case "FirstValueEnum":  return .FirstValueEnum
          case "SecondValueEnum":  return .SecondValueEnum
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .FirstValueEnum: return ".FirstValueEnum"
                case .SecondValueEnum: return ".SecondValueEnum"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var hasMapInt32Int32:Bool = false
    public private(set) var mapInt32Int32:Dictionary<Int32,Int32> = Dictionary<Int32,Int32>()

    public private(set) var hasMapInt64Int64:Bool = false
    public private(set) var mapInt64Int64:Dictionary<Int64,Int64> = Dictionary<Int64,Int64>()

    public private(set) var hasMapStringString:Bool = false
    public private(set) var mapStringString:Dictionary<String,String> = Dictionary<String,String>()

    public private(set) var hasMapStringBytes:Bool = false
    public private(set) var mapStringBytes:Dictionary<String,NSData> = Dictionary<String,NSData>()

    public private(set) var hasMapStringMessage:Bool = false
    public private(set) var mapStringMessage:Dictionary<String,SwiftProtobufUnittest.MapMessageValue> = Dictionary<String,SwiftProtobufUnittest.MapMessageValue>()

    public private(set) var hasMapInt32Enum:Bool = false
    public private(set) var mapInt32Enum:Dictionary<Int32,SwiftProtobufUnittest.MessageContainsMap.EnumMapValue> = Dictionary<Int32,SwiftProtobufUnittest.MessageContainsMap.EnumMapValue>()

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasMapInt32Int32 {
          for (keyMapInt32Int32, valueMapInt32Int32) in mapInt32Int32 {
              let valueOfMapInt32Int32 = try! SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().setKey(keyMapInt32Int32).setValue(valueMapInt32Int32).build()
              try output.writeMessage(1, value:valueOfMapInt32Int32)
          }
      }
      if hasMapInt64Int64 {
          for (keyMapInt64Int64, valueMapInt64Int64) in mapInt64Int64 {
              let valueOfMapInt64Int64 = try! SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().setKey(keyMapInt64Int64).setValue(valueMapInt64Int64).build()
              try output.writeMessage(2, value:valueOfMapInt64Int64)
          }
      }
      if hasMapStringString {
          for (keyMapStringString, valueMapStringString) in mapStringString {
              let valueOfMapStringString = try! SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().setKey(keyMapStringString).setValue(valueMapStringString).build()
              try output.writeMessage(3, value:valueOfMapStringString)
          }
      }
      if hasMapStringBytes {
          for (keyMapStringBytes, valueMapStringBytes) in mapStringBytes {
              let valueOfMapStringBytes = try! SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().setKey(keyMapStringBytes).setValue(valueMapStringBytes).build()
              try output.writeMessage(4, value:valueOfMapStringBytes)
          }
      }
      if hasMapStringMessage {
          for (keyMapStringMessage, valueMapStringMessage) in mapStringMessage {
              let valueOfMapStringMessage = try! SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().setKey(keyMapStringMessage).setValue(valueMapStringMessage).build()
              try output.writeMessage(5, value:valueOfMapStringMessage)
          }
      }
      if hasMapInt32Enum {
          for (keyMapInt32Enum, valueMapInt32Enum) in mapInt32Enum {
              let valueOfMapInt32Enum = try! SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().setKey(keyMapInt32Enum).setValue(valueMapInt32Enum).build()
              try output.writeMessage(6, value:valueOfMapInt32Enum)
          }
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasMapInt32Int32 {
          for (keyMapInt32Int32, valueMapInt32Int32) in mapInt32Int32 {
              let valueOfMapInt32Int32 = try! SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder().setKey(keyMapInt32Int32).setValue(valueMapInt32Int32).build()
              serialize_size += valueOfMapInt32Int32.computeMessageSize(1)
          }
      }
      if hasMapInt64Int64 {
          for (keyMapInt64Int64, valueMapInt64Int64) in mapInt64Int64 {
              let valueOfMapInt64Int64 = try! SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder().setKey(keyMapInt64Int64).setValue(valueMapInt64Int64).build()
              serialize_size += valueOfMapInt64Int64.computeMessageSize(2)
          }
      }
      if hasMapStringString {
          for (keyMapStringString, valueMapStringString) in mapStringString {
              let valueOfMapStringString = try! SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder().setKey(keyMapStringString).setValue(valueMapStringString).build()
              serialize_size += valueOfMapStringString.computeMessageSize(3)
          }
      }
      if hasMapStringBytes {
          for (keyMapStringBytes, valueMapStringBytes) in mapStringBytes {
              let valueOfMapStringBytes = try! SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder().setKey(keyMapStringBytes).setValue(valueMapStringBytes).build()
              serialize_size += valueOfMapStringBytes.computeMessageSize(4)
          }
      }
      if hasMapStringMessage {
          for (keyMapStringMessage, valueMapStringMessage) in mapStringMessage {
              let valueOfMapStringMessage = try! SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder().setKey(keyMapStringMessage).setValue(valueMapStringMessage).build()
              serialize_size += valueOfMapStringMessage.computeMessageSize(5)
          }
      }
      if hasMapInt32Enum {
          for (keyMapInt32Enum, valueMapInt32Enum) in mapInt32Enum {
              let valueOfMapInt32Enum = try! SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder().setKey(keyMapInt32Enum).setValue(valueMapInt32Enum).build()
              serialize_size += valueOfMapInt32Enum.computeMessageSize(6)
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<SwiftProtobufUnittest.MessageContainsMap> {
      var mergedArray = Array<SwiftProtobufUnittest.MessageContainsMap>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap? {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFromData(data, extensionRegistry:SwiftProtobufUnittest.UnittestMapsRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.Builder {
      return SwiftProtobufUnittest.MessageContainsMap.classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.Builder
    }
    public func getBuilder() -> SwiftProtobufUnittest.MessageContainsMap.Builder {
      return classBuilder() as! SwiftProtobufUnittest.MessageContainsMap.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return SwiftProtobufUnittest.MessageContainsMap.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return SwiftProtobufUnittest.MessageContainsMap.Builder()
    }
    public func toBuilder() throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
      return try SwiftProtobufUnittest.MessageContainsMap.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:SwiftProtobufUnittest.MessageContainsMap) throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasMapInt32Int32 {
          var mapMapInt32Int32 = Dictionary<String, NSNumber>()
          for (keyMapInt32Int32, valueMapInt32Int32) in mapInt32Int32 {
              mapMapInt32Int32["\(keyMapInt32Int32)"] = NSNumber(int:valueMapInt32Int32)
          }
          jsonMap["mapInt32Int32"] = mapMapInt32Int32
      }
      if hasMapInt64Int64 {
          var mapMapInt64Int64 = Dictionary<String, String>()
          for (keyMapInt64Int64, valueMapInt64Int64) in mapInt64Int64 {
              mapMapInt64Int64["\(keyMapInt64Int64)"] = "\(valueMapInt64Int64)"
          }
          jsonMap["mapInt64Int64"] = mapMapInt64Int64
      }
      if hasMapStringString {
          var mapMapStringString = Dictionary<String, String>()
          for (keyMapStringString, valueMapStringString) in mapStringString {
              mapMapStringString["\(keyMapStringString)"] = valueMapStringString
          }
          jsonMap["mapStringString"] = mapMapStringString
      }
      if hasMapStringBytes {
          var mapMapStringBytes = Dictionary<String, String>()
          for (keyMapStringBytes, valueMapStringBytes) in mapStringBytes {
              mapMapStringBytes["\(keyMapStringBytes)"] = valueMapStringBytes.base64EncodedStringWithOptions(NSDataBase64EncodingOptions(rawValue: 0))
          }
          jsonMap["mapStringBytes"] = mapMapStringBytes
      }
      if hasMapStringMessage {
          var mapMapStringMessage = Dictionary<String, Dictionary<String,AnyObject>>()
          for (keyMapStringMessage, valueMapStringMessage) in mapStringMessage {
              mapMapStringMessage["\(keyMapStringMessage)"] = try valueMapStringMessage.encode()
          }
          jsonMap["mapStringMessage"] = mapMapStringMessage
      }
      if hasMapInt32Enum {
          var mapMapInt32Enum = Dictionary<String, String>()
          for (keyMapInt32Enum, valueMapInt32Enum) in mapInt32Enum {
              mapMapInt32Enum["\(keyMapInt32Enum)"] = valueMapInt32Enum.toString()
          }
          jsonMap["mapInt32Enum"] = mapMapInt32Enum
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap {
      return try SwiftProtobufUnittest.MessageContainsMap.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasMapInt32Int32 {
        output += "\(indent) mapInt32Int32: \(mapInt32Int32) \n"
      }
      if hasMapInt64Int64 {
        output += "\(indent) mapInt64Int64: \(mapInt64Int64) \n"
      }
      if hasMapStringString {
        output += "\(indent) mapStringString: \(mapStringString) \n"
      }
      if hasMapStringBytes {
        output += "\(indent) mapStringBytes: \(mapStringBytes) \n"
      }
      if hasMapStringMessage {
        output += "\(indent) mapStringMessage: \(mapStringMessage) \n"
      }
      if hasMapInt32Enum {
        output += "\(indent) mapInt32Enum: \(mapInt32Enum) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasMapInt32Int32 {
                for (keyMapInt32Int32, valueMapInt32Int32) in mapInt32Int32 {
                    hashCode = (hashCode &* 31) &+ keyMapInt32Int32.hashValue
                    hashCode = (hashCode &* 31) &+ valueMapInt32Int32.hashValue
                }
            }
            if hasMapInt64Int64 {
                for (keyMapInt64Int64, valueMapInt64Int64) in mapInt64Int64 {
                    hashCode = (hashCode &* 31) &+ keyMapInt64Int64.hashValue
                    hashCode = (hashCode &* 31) &+ valueMapInt64Int64.hashValue
                }
            }
            if hasMapStringString {
                for (keyMapStringString, valueMapStringString) in mapStringString {
                    hashCode = (hashCode &* 31) &+ keyMapStringString.hashValue
                    hashCode = (hashCode &* 31) &+ valueMapStringString.hashValue
                }
            }
            if hasMapStringBytes {
                for (keyMapStringBytes, valueMapStringBytes) in mapStringBytes {
                    hashCode = (hashCode &* 31) &+ keyMapStringBytes.hashValue
                    hashCode = (hashCode &* 31) &+ valueMapStringBytes.hashValue
                }
            }
            if hasMapStringMessage {
                for (keyMapStringMessage, valueMapStringMessage) in mapStringMessage {
                    hashCode = (hashCode &* 31) &+ keyMapStringMessage.hashValue
                    hashCode = (hashCode &* 31) &+ valueMapStringMessage.hashValue
                }
            }
            if hasMapInt32Enum {
                for (keyMapInt32Enum, valueMapInt32Enum) in mapInt32Enum {
                    hashCode = (hashCode &* 31) &+ keyMapInt32Enum.hashValue
                    hashCode = (hashCode &* 31) &+ valueMapInt32Enum.hashValue
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "SwiftProtobufUnittest.MessageContainsMap"
    }
    override public func className() -> String {
        return "SwiftProtobufUnittest.MessageContainsMap"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return SwiftProtobufUnittest.MessageContainsMap.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:SwiftProtobufUnittest.MessageContainsMap = SwiftProtobufUnittest.MessageContainsMap()
      public func getMessage() -> SwiftProtobufUnittest.MessageContainsMap {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasMapInt32Int32:Bool {
           get {
                return builderResult.hasMapInt32Int32
           }
      }
      public var mapInt32Int32:Dictionary<Int32,Int32> {
           get {
                return builderResult.mapInt32Int32
           }
           set (value) {
               builderResult.hasMapInt32Int32 = true
               builderResult.mapInt32Int32 = value
           }
      }
      public func setMapInt32Int32(value:Dictionary<Int32,Int32>) -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        self.mapInt32Int32 = value
        return self
      }
      public func clearMapInt32Int32() -> SwiftProtobufUnittest.MessageContainsMap.Builder{
           builderResult.hasMapInt32Int32 = false
           builderResult.mapInt32Int32 = Dictionary<Int32,Int32>()
           return self
      }
      public var hasMapInt64Int64:Bool {
           get {
                return builderResult.hasMapInt64Int64
           }
      }
      public var mapInt64Int64:Dictionary<Int64,Int64> {
           get {
                return builderResult.mapInt64Int64
           }
           set (value) {
               builderResult.hasMapInt64Int64 = true
               builderResult.mapInt64Int64 = value
           }
      }
      public func setMapInt64Int64(value:Dictionary<Int64,Int64>) -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        self.mapInt64Int64 = value
        return self
      }
      public func clearMapInt64Int64() -> SwiftProtobufUnittest.MessageContainsMap.Builder{
           builderResult.hasMapInt64Int64 = false
           builderResult.mapInt64Int64 = Dictionary<Int64,Int64>()
           return self
      }
      public var hasMapStringString:Bool {
           get {
                return builderResult.hasMapStringString
           }
      }
      public var mapStringString:Dictionary<String,String> {
           get {
                return builderResult.mapStringString
           }
           set (value) {
               builderResult.hasMapStringString = true
               builderResult.mapStringString = value
           }
      }
      public func setMapStringString(value:Dictionary<String,String>) -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        self.mapStringString = value
        return self
      }
      public func clearMapStringString() -> SwiftProtobufUnittest.MessageContainsMap.Builder{
           builderResult.hasMapStringString = false
           builderResult.mapStringString = Dictionary<String,String>()
           return self
      }
      public var hasMapStringBytes:Bool {
           get {
                return builderResult.hasMapStringBytes
           }
      }
      public var mapStringBytes:Dictionary<String,NSData> {
           get {
                return builderResult.mapStringBytes
           }
           set (value) {
               builderResult.hasMapStringBytes = true
               builderResult.mapStringBytes = value
           }
      }
      public func setMapStringBytes(value:Dictionary<String,NSData>) -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        self.mapStringBytes = value
        return self
      }
      public func clearMapStringBytes() -> SwiftProtobufUnittest.MessageContainsMap.Builder{
           builderResult.hasMapStringBytes = false
           builderResult.mapStringBytes = Dictionary<String,NSData>()
           return self
      }
      public var hasMapStringMessage:Bool {
           get {
                return builderResult.hasMapStringMessage
           }
      }
      public var mapStringMessage:Dictionary<String,SwiftProtobufUnittest.MapMessageValue> {
           get {
                return builderResult.mapStringMessage
           }
           set (value) {
               builderResult.hasMapStringMessage = true
               builderResult.mapStringMessage = value
           }
      }
      public func setMapStringMessage(value:Dictionary<String,SwiftProtobufUnittest.MapMessageValue>) -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        self.mapStringMessage = value
        return self
      }
      public func clearMapStringMessage() -> SwiftProtobufUnittest.MessageContainsMap.Builder{
           builderResult.hasMapStringMessage = false
           builderResult.mapStringMessage = Dictionary<String,SwiftProtobufUnittest.MapMessageValue>()
           return self
      }
      public var hasMapInt32Enum:Bool {
           get {
                return builderResult.hasMapInt32Enum
           }
      }
      public var mapInt32Enum:Dictionary<Int32,SwiftProtobufUnittest.MessageContainsMap.EnumMapValue> {
           get {
                return builderResult.mapInt32Enum
           }
           set (value) {
               builderResult.hasMapInt32Enum = true
               builderResult.mapInt32Enum = value
           }
      }
      public func setMapInt32Enum(value:Dictionary<Int32,SwiftProtobufUnittest.MessageContainsMap.EnumMapValue>) -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        self.mapInt32Enum = value
        return self
      }
      public func clearMapInt32Enum() -> SwiftProtobufUnittest.MessageContainsMap.Builder{
           builderResult.hasMapInt32Enum = false
           builderResult.mapInt32Enum = Dictionary<Int32,SwiftProtobufUnittest.MessageContainsMap.EnumMapValue>()
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        builderResult = SwiftProtobufUnittest.MessageContainsMap()
        return self
      }
      override public func clone() throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        return try SwiftProtobufUnittest.MessageContainsMap.builderWithPrototype(builderResult)
      }
      override public func build() throws -> SwiftProtobufUnittest.MessageContainsMap {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> SwiftProtobufUnittest.MessageContainsMap {
        let returnMe:SwiftProtobufUnittest.MessageContainsMap = builderResult
        return returnMe
      }
      public func mergeFrom(other:SwiftProtobufUnittest.MessageContainsMap) throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        if other == SwiftProtobufUnittest.MessageContainsMap() {
         return self
        }
        if other.hasMapInt32Int32 {
             mapInt32Int32 = other.mapInt32Int32
        }
        if other.hasMapInt64Int64 {
             mapInt64Int64 = other.mapInt64Int64
        }
        if other.hasMapStringString {
             mapStringString = other.mapStringString
        }
        if other.hasMapStringBytes {
             mapStringBytes = other.mapStringBytes
        }
        if other.hasMapStringMessage {
             mapStringMessage = other.mapStringMessage
        }
        if other.hasMapInt32Enum {
             mapInt32Enum = other.mapInt32Enum
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            let subBuilder = SwiftProtobufUnittest.MessageContainsMap.MapInt32Int32Entry.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            let buildOfMapInt32Int32 = subBuilder.buildPartial()
            mapInt32Int32[buildOfMapInt32Int32.key] = buildOfMapInt32Int32.value

          case 18 :
            let subBuilder = SwiftProtobufUnittest.MessageContainsMap.MapInt64Int64Entry.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            let buildOfMapInt64Int64 = subBuilder.buildPartial()
            mapInt64Int64[buildOfMapInt64Int64.key] = buildOfMapInt64Int64.value

          case 26 :
            let subBuilder = SwiftProtobufUnittest.MessageContainsMap.MapStringStringEntry.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            let buildOfMapStringString = subBuilder.buildPartial()
            mapStringString[buildOfMapStringString.key] = buildOfMapStringString.value

          case 34 :
            let subBuilder = SwiftProtobufUnittest.MessageContainsMap.MapStringBytesEntry.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            let buildOfMapStringBytes = subBuilder.buildPartial()
            mapStringBytes[buildOfMapStringBytes.key] = buildOfMapStringBytes.value

          case 42 :
            let subBuilder = SwiftProtobufUnittest.MessageContainsMap.MapStringMessageEntry.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            let buildOfMapStringMessage = subBuilder.buildPartial()
            mapStringMessage[buildOfMapStringMessage.key] = buildOfMapStringMessage.value

          case 50 :
            let subBuilder = SwiftProtobufUnittest.MessageContainsMap.MapInt32EnumEntry.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            let buildOfMapInt32Enum = subBuilder.buildPartial()
            mapInt32Enum[buildOfMapInt32Enum.key] = buildOfMapInt32Enum.value

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        let resultDecodedBuilder = SwiftProtobufUnittest.MessageContainsMap.Builder()
        if let jsonValueMapInt32Int32 = jsonMap["mapInt32Int32"] as? Dictionary<String, NSNumber> {
            var mapMapInt32Int32 = Dictionary<Int32, Int32>()
            for (keyMapInt32Int32, valueMapInt32Int32) in jsonValueMapInt32Int32 {
                let keyFromMapInt32Int32 = Int32(keyMapInt32Int32)!
                mapMapInt32Int32[keyFromMapInt32Int32] = valueMapInt32Int32.intValue
            }
            resultDecodedBuilder.mapInt32Int32 = mapMapInt32Int32
        }
        if let jsonValueMapInt64Int64 = jsonMap["mapInt64Int64"] as? Dictionary<String, String> {
            var mapMapInt64Int64 = Dictionary<Int64, Int64>()
            for (keyMapInt64Int64, valueMapInt64Int64) in jsonValueMapInt64Int64 {
                let keyFromMapInt64Int64 = Int64(keyMapInt64Int64)!
                mapMapInt64Int64[keyFromMapInt64Int64] = Int64(valueMapInt64Int64)!
            }
            resultDecodedBuilder.mapInt64Int64 = mapMapInt64Int64
        }
        if let jsonValueMapStringString = jsonMap["mapStringString"] as? Dictionary<String, String> {
            var mapMapStringString = Dictionary<String, String>()
            for (keyMapStringString, valueMapStringString) in jsonValueMapStringString {
                let keyFromMapStringString = keyMapStringString
                mapMapStringString[keyFromMapStringString] = valueMapStringString
            }
            resultDecodedBuilder.mapStringString = mapMapStringString
        }
        if let jsonValueMapStringBytes = jsonMap["mapStringBytes"] as? Dictionary<String, String> {
            var mapMapStringBytes = Dictionary<String, NSData>()
            for (keyMapStringBytes, valueMapStringBytes) in jsonValueMapStringBytes {
                let keyFromMapStringBytes = keyMapStringBytes
                mapMapStringBytes[keyFromMapStringBytes] = NSData(base64EncodedString:valueMapStringBytes, options: NSDataBase64DecodingOptions(rawValue:0))!
            }
            resultDecodedBuilder.mapStringBytes = mapMapStringBytes
        }
        if let jsonValueMapStringMessage = jsonMap["mapStringMessage"] as? Dictionary<String, Dictionary<String,AnyObject>> {
            var mapMapStringMessage = Dictionary<String, SwiftProtobufUnittest.MapMessageValue>()
            for (keyMapStringMessage, valueMapStringMessage) in jsonValueMapStringMessage {
                let keyFromMapStringMessage = keyMapStringMessage
                mapMapStringMessage[keyFromMapStringMessage] = try SwiftProtobufUnittest.MapMessageValue.Builder.decodeToBuilder(valueMapStringMessage).build()

            }
            resultDecodedBuilder.mapStringMessage = mapMapStringMessage
        }
        if let jsonValueMapInt32Enum = jsonMap["mapInt32Enum"] as? Dictionary<String, String> {
            var mapMapInt32Enum = Dictionary<Int32, SwiftProtobufUnittest.MessageContainsMap.EnumMapValue>()
            for (keyMapInt32Enum, valueMapInt32Enum) in jsonValueMapInt32Enum {
                let keyFromMapInt32Enum = Int32(keyMapInt32Enum)!
                mapMapInt32Enum[keyFromMapInt32Enum] = try SwiftProtobufUnittest.MessageContainsMap.EnumMapValue.fromString(valueMapInt32Enum)
            }
            resultDecodedBuilder.mapInt32Enum = mapMapInt32Enum
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> SwiftProtobufUnittest.MessageContainsMap.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try SwiftProtobufUnittest.MessageContainsMap.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)

// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "unittest_proto3_arena.proto"
// Syntax "Proto3"

import Foundation
import ProtocolBuffers

public struct Proto3ArenaUnittest { }

public func == (lhs: Proto3ArenaUnittest.TestAllTypes, rhs: Proto3ArenaUnittest.TestAllTypes) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasOptionalInt32 == rhs.hasOptionalInt32) && (!lhs.hasOptionalInt32 || lhs.optionalInt32 == rhs.optionalInt32)
  fieldCheck = fieldCheck && (lhs.hasOptionalInt64 == rhs.hasOptionalInt64) && (!lhs.hasOptionalInt64 || lhs.optionalInt64 == rhs.optionalInt64)
  fieldCheck = fieldCheck && (lhs.hasOptionalUint32 == rhs.hasOptionalUint32) && (!lhs.hasOptionalUint32 || lhs.optionalUint32 == rhs.optionalUint32)
  fieldCheck = fieldCheck && (lhs.hasOptionalUint64 == rhs.hasOptionalUint64) && (!lhs.hasOptionalUint64 || lhs.optionalUint64 == rhs.optionalUint64)
  fieldCheck = fieldCheck && (lhs.hasOptionalSint32 == rhs.hasOptionalSint32) && (!lhs.hasOptionalSint32 || lhs.optionalSint32 == rhs.optionalSint32)
  fieldCheck = fieldCheck && (lhs.hasOptionalSint64 == rhs.hasOptionalSint64) && (!lhs.hasOptionalSint64 || lhs.optionalSint64 == rhs.optionalSint64)
  fieldCheck = fieldCheck && (lhs.hasOptionalFixed32 == rhs.hasOptionalFixed32) && (!lhs.hasOptionalFixed32 || lhs.optionalFixed32 == rhs.optionalFixed32)
  fieldCheck = fieldCheck && (lhs.hasOptionalFixed64 == rhs.hasOptionalFixed64) && (!lhs.hasOptionalFixed64 || lhs.optionalFixed64 == rhs.optionalFixed64)
  fieldCheck = fieldCheck && (lhs.hasOptionalSfixed32 == rhs.hasOptionalSfixed32) && (!lhs.hasOptionalSfixed32 || lhs.optionalSfixed32 == rhs.optionalSfixed32)
  fieldCheck = fieldCheck && (lhs.hasOptionalSfixed64 == rhs.hasOptionalSfixed64) && (!lhs.hasOptionalSfixed64 || lhs.optionalSfixed64 == rhs.optionalSfixed64)
  fieldCheck = fieldCheck && (lhs.hasOptionalFloat == rhs.hasOptionalFloat) && (!lhs.hasOptionalFloat || lhs.optionalFloat == rhs.optionalFloat)
  fieldCheck = fieldCheck && (lhs.hasOptionalDouble == rhs.hasOptionalDouble) && (!lhs.hasOptionalDouble || lhs.optionalDouble == rhs.optionalDouble)
  fieldCheck = fieldCheck && (lhs.hasOptionalBool == rhs.hasOptionalBool) && (!lhs.hasOptionalBool || lhs.optionalBool == rhs.optionalBool)
  fieldCheck = fieldCheck && (lhs.hasOptionalString == rhs.hasOptionalString) && (!lhs.hasOptionalString || lhs.optionalString == rhs.optionalString)
  fieldCheck = fieldCheck && (lhs.hasOptionalBytes == rhs.hasOptionalBytes) && (!lhs.hasOptionalBytes || lhs.optionalBytes == rhs.optionalBytes)
  fieldCheck = fieldCheck && (lhs.hasOptionalNestedMessage == rhs.hasOptionalNestedMessage) && (!lhs.hasOptionalNestedMessage || lhs.optionalNestedMessage == rhs.optionalNestedMessage)
  fieldCheck = fieldCheck && (lhs.hasOptionalForeignMessage == rhs.hasOptionalForeignMessage) && (!lhs.hasOptionalForeignMessage || lhs.optionalForeignMessage == rhs.optionalForeignMessage)
  fieldCheck = fieldCheck && (lhs.hasOptionalImportMessage == rhs.hasOptionalImportMessage) && (!lhs.hasOptionalImportMessage || lhs.optionalImportMessage == rhs.optionalImportMessage)
  fieldCheck = fieldCheck && (lhs.hasOptionalNestedEnum == rhs.hasOptionalNestedEnum) && (!lhs.hasOptionalNestedEnum || lhs.optionalNestedEnum == rhs.optionalNestedEnum)
  fieldCheck = fieldCheck && (lhs.hasOptionalForeignEnum == rhs.hasOptionalForeignEnum) && (!lhs.hasOptionalForeignEnum || lhs.optionalForeignEnum == rhs.optionalForeignEnum)
  fieldCheck = fieldCheck && (lhs.hasOptionalStringPiece == rhs.hasOptionalStringPiece) && (!lhs.hasOptionalStringPiece || lhs.optionalStringPiece == rhs.optionalStringPiece)
  fieldCheck = fieldCheck && (lhs.hasOptionalCord == rhs.hasOptionalCord) && (!lhs.hasOptionalCord || lhs.optionalCord == rhs.optionalCord)
  fieldCheck = fieldCheck && (lhs.hasOptionalPublicImportMessage == rhs.hasOptionalPublicImportMessage) && (!lhs.hasOptionalPublicImportMessage || lhs.optionalPublicImportMessage == rhs.optionalPublicImportMessage)
  fieldCheck = fieldCheck && (lhs.hasOptionalLazyMessage == rhs.hasOptionalLazyMessage) && (!lhs.hasOptionalLazyMessage || lhs.optionalLazyMessage == rhs.optionalLazyMessage)
  fieldCheck = fieldCheck && (lhs.repeatedInt32 == rhs.repeatedInt32)
  fieldCheck = fieldCheck && (lhs.repeatedInt64 == rhs.repeatedInt64)
  fieldCheck = fieldCheck && (lhs.repeatedUint32 == rhs.repeatedUint32)
  fieldCheck = fieldCheck && (lhs.repeatedUint64 == rhs.repeatedUint64)
  fieldCheck = fieldCheck && (lhs.repeatedSint32 == rhs.repeatedSint32)
  fieldCheck = fieldCheck && (lhs.repeatedSint64 == rhs.repeatedSint64)
  fieldCheck = fieldCheck && (lhs.repeatedFixed32 == rhs.repeatedFixed32)
  fieldCheck = fieldCheck && (lhs.repeatedFixed64 == rhs.repeatedFixed64)
  fieldCheck = fieldCheck && (lhs.repeatedSfixed32 == rhs.repeatedSfixed32)
  fieldCheck = fieldCheck && (lhs.repeatedSfixed64 == rhs.repeatedSfixed64)
  fieldCheck = fieldCheck && (lhs.repeatedFloat == rhs.repeatedFloat)
  fieldCheck = fieldCheck && (lhs.repeatedDouble == rhs.repeatedDouble)
  fieldCheck = fieldCheck && (lhs.repeatedBool == rhs.repeatedBool)
  fieldCheck = fieldCheck && (lhs.repeatedString == rhs.repeatedString)
  fieldCheck = fieldCheck && (lhs.repeatedBytes == rhs.repeatedBytes)
  fieldCheck = fieldCheck && (lhs.repeatedNestedMessage == rhs.repeatedNestedMessage)
  fieldCheck = fieldCheck && (lhs.repeatedForeignMessage == rhs.repeatedForeignMessage)
  fieldCheck = fieldCheck && (lhs.repeatedImportMessage == rhs.repeatedImportMessage)
  fieldCheck = fieldCheck && (lhs.repeatedNestedEnum == rhs.repeatedNestedEnum)
  fieldCheck = fieldCheck && (lhs.repeatedForeignEnum == rhs.repeatedForeignEnum)
  fieldCheck = fieldCheck && (lhs.repeatedStringPiece == rhs.repeatedStringPiece)
  fieldCheck = fieldCheck && (lhs.repeatedCord == rhs.repeatedCord)
  fieldCheck = fieldCheck && (lhs.repeatedLazyMessage == rhs.repeatedLazyMessage)
  fieldCheck = fieldCheck && (lhs.hasOneofUint32 == rhs.hasOneofUint32) && (!lhs.hasOneofUint32 || lhs.oneofUint32 == rhs.oneofUint32)
  fieldCheck = fieldCheck && (lhs.hasOneofNestedMessage == rhs.hasOneofNestedMessage) && (!lhs.hasOneofNestedMessage || lhs.oneofNestedMessage == rhs.oneofNestedMessage)
  fieldCheck = fieldCheck && (lhs.hasOneofString == rhs.hasOneofString) && (!lhs.hasOneofString || lhs.oneofString == rhs.oneofString)
  fieldCheck = fieldCheck && (lhs.hasOneofBytes == rhs.hasOneofBytes) && (!lhs.hasOneofBytes || lhs.oneofBytes == rhs.oneofBytes)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Proto3ArenaUnittest.TestAllTypes.NestedMessage, rhs: Proto3ArenaUnittest.TestAllTypes.NestedMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBb == rhs.hasBb) && (!lhs.hasBb || lhs.bb == rhs.bb)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Proto3ArenaUnittest.TestPackedTypes, rhs: Proto3ArenaUnittest.TestPackedTypes) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.packedInt32 == rhs.packedInt32)
  fieldCheck = fieldCheck && (lhs.packedInt64 == rhs.packedInt64)
  fieldCheck = fieldCheck && (lhs.packedUint32 == rhs.packedUint32)
  fieldCheck = fieldCheck && (lhs.packedUint64 == rhs.packedUint64)
  fieldCheck = fieldCheck && (lhs.packedSint32 == rhs.packedSint32)
  fieldCheck = fieldCheck && (lhs.packedSint64 == rhs.packedSint64)
  fieldCheck = fieldCheck && (lhs.packedFixed32 == rhs.packedFixed32)
  fieldCheck = fieldCheck && (lhs.packedFixed64 == rhs.packedFixed64)
  fieldCheck = fieldCheck && (lhs.packedSfixed32 == rhs.packedSfixed32)
  fieldCheck = fieldCheck && (lhs.packedSfixed64 == rhs.packedSfixed64)
  fieldCheck = fieldCheck && (lhs.packedFloat == rhs.packedFloat)
  fieldCheck = fieldCheck && (lhs.packedDouble == rhs.packedDouble)
  fieldCheck = fieldCheck && (lhs.packedBool == rhs.packedBool)
  fieldCheck = fieldCheck && (lhs.packedEnum == rhs.packedEnum)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Proto3ArenaUnittest.TestUnpackedTypes, rhs: Proto3ArenaUnittest.TestUnpackedTypes) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.repeatedInt32 == rhs.repeatedInt32)
  fieldCheck = fieldCheck && (lhs.repeatedInt64 == rhs.repeatedInt64)
  fieldCheck = fieldCheck && (lhs.repeatedUint32 == rhs.repeatedUint32)
  fieldCheck = fieldCheck && (lhs.repeatedUint64 == rhs.repeatedUint64)
  fieldCheck = fieldCheck && (lhs.repeatedSint32 == rhs.repeatedSint32)
  fieldCheck = fieldCheck && (lhs.repeatedSint64 == rhs.repeatedSint64)
  fieldCheck = fieldCheck && (lhs.repeatedFixed32 == rhs.repeatedFixed32)
  fieldCheck = fieldCheck && (lhs.repeatedFixed64 == rhs.repeatedFixed64)
  fieldCheck = fieldCheck && (lhs.repeatedSfixed32 == rhs.repeatedSfixed32)
  fieldCheck = fieldCheck && (lhs.repeatedSfixed64 == rhs.repeatedSfixed64)
  fieldCheck = fieldCheck && (lhs.repeatedFloat == rhs.repeatedFloat)
  fieldCheck = fieldCheck && (lhs.repeatedDouble == rhs.repeatedDouble)
  fieldCheck = fieldCheck && (lhs.repeatedBool == rhs.repeatedBool)
  fieldCheck = fieldCheck && (lhs.repeatedNestedEnum == rhs.repeatedNestedEnum)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Proto3ArenaUnittest.NestedTestAllTypes, rhs: Proto3ArenaUnittest.NestedTestAllTypes) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasChild == rhs.hasChild) && (!lhs.hasChild || lhs.child == rhs.child)
  fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Proto3ArenaUnittest.ForeignMessage, rhs: Proto3ArenaUnittest.ForeignMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasC == rhs.hasC) && (!lhs.hasC || lhs.c == rhs.c)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Proto3ArenaUnittest.TestEmptyMessage, rhs: Proto3ArenaUnittest.TestEmptyMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public extension Proto3ArenaUnittest {
  public struct UnittestProto3ArenaRoot {
    public static var sharedInstance : UnittestProto3ArenaRoot {
     struct Static {
         static let instance : UnittestProto3ArenaRoot = UnittestProto3ArenaRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
      ProtobufUnittestImport.UnittestImportRoot.sharedInstance.registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }



  //Enum type declaration start 

  public enum ForeignEnum:Int32 {
    case ForeignZero = 0
    case ForeignFoo = 4
    case ForeignBar = 5
    case ForeignBaz = 6
    public func toString() -> String {
      switch self {
      case .ForeignZero: return "FOREIGN_ZERO"
      case .ForeignFoo: return "FOREIGN_FOO"
      case .ForeignBar: return "FOREIGN_BAR"
      case .ForeignBaz: return "FOREIGN_BAZ"
      }
    }
    public static func fromString(str:String) throws -> Proto3ArenaUnittest.ForeignEnum {
      switch str {
      case "FOREIGN_ZERO":  return .ForeignZero
      case "FOREIGN_FOO":  return .ForeignFoo
      case "FOREIGN_BAR":  return .ForeignBar
      case "FOREIGN_BAZ":  return .ForeignBaz
      default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
      }
    }
  }

  //Enum type declaration end 

  // This proto includes every type of field in both singular and repeated
  // forms.
  final public class TestAllTypes : GeneratedMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      final public class NestedMessage : GeneratedMessage, GeneratedMessageProtocol {
        // The field name "b" fails to compile in proto1 because it conflicts with
        // a local variable named "b" in one of the generated methods.  Doh.
        // This file needs to compile in proto1 to test backwards-compatibility.
        public private(set) var hasBb:Bool = false
        public private(set) var bb:Int32 = Int32(0)

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasBb {
            try output.writeInt32(1, value:bb)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasBb {
            serialize_size += bb.computeInt32Size(1)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Proto3ArenaUnittest.TestAllTypes.NestedMessage> {
          var mergedArray = Array<Proto3ArenaUnittest.TestAllTypes.NestedMessage>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage? {
          return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage {
          return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder().mergeFromData(data, extensionRegistry:Proto3ArenaUnittest.UnittestProto3ArenaRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage {
          return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage {
          return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage {
          return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage {
          return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage {
          return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
          return Proto3ArenaUnittest.TestAllTypes.NestedMessage.classBuilder() as! Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder
        }
        public func getBuilder() -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
          return classBuilder() as! Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder()
        }
        public func toBuilder() throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
          return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:Proto3ArenaUnittest.TestAllTypes.NestedMessage) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
          return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if hasBb {
            jsonMap["bb"] = NSNumber(int:bb)
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage {
          return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(data:NSData) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage {
          return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasBb {
            output += "\(indent) bb: \(bb) \n"
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasBb {
                   hashCode = (hashCode &* 31) &+ bb.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Proto3ArenaUnittest.TestAllTypes.NestedMessage"
        }
        override public func className() -> String {
            return "Proto3ArenaUnittest.TestAllTypes.NestedMessage"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return Proto3ArenaUnittest.TestAllTypes.NestedMessage.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:Proto3ArenaUnittest.TestAllTypes.NestedMessage = Proto3ArenaUnittest.TestAllTypes.NestedMessage()
          public func getMessage() -> Proto3ArenaUnittest.TestAllTypes.NestedMessage {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasBb:Bool {
               get {
                    return builderResult.hasBb
               }
          }
          public var bb:Int32 {
               get {
                    return builderResult.bb
               }
               set (value) {
                   builderResult.hasBb = true
                   builderResult.bb = value
               }
          }
          public func setBb(value:Int32) -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
            self.bb = value
            return self
          }
          public func clearBb() -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder{
               builderResult.hasBb = false
               builderResult.bb = Int32(0)
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
            builderResult = Proto3ArenaUnittest.TestAllTypes.NestedMessage()
            return self
          }
          override public func clone() throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
            return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.builderWithPrototype(builderResult)
          }
          override public func build() throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Proto3ArenaUnittest.TestAllTypes.NestedMessage {
            let returnMe:Proto3ArenaUnittest.TestAllTypes.NestedMessage = builderResult
            return returnMe
          }
          public func mergeFrom(other:Proto3ArenaUnittest.TestAllTypes.NestedMessage) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
            if other == Proto3ArenaUnittest.TestAllTypes.NestedMessage() {
             return self
            }
            if other.hasBb {
                 bb = other.bb
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                bb = try input.readInt32()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
            let resultDecodedBuilder = Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder()
            if let jsonValueBb = jsonMap["bb"] as? NSNumber {
              resultDecodedBuilder.bb = jsonValueBb.intValue
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:NSData) throws -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
            let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
            }
            return try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //OneOf declaration start

    public enum OneofField {
      case OneofFieldOneOfNotSet

      public func checkOneOfIsSet() -> Bool {
           switch self {
           case .OneofFieldOneOfNotSet:
                return false
           default:
                return true
           }
      }
      case OneofUint32(UInt32)

      public static func getOneofUint32(value:OneofField) -> UInt32? {
           switch value {
           case .OneofUint32(let enumValue):
                return enumValue
           default:
                return nil
           }
      }
      case OneofNestedMessage(Proto3ArenaUnittest.TestAllTypes.NestedMessage)

      public static func getOneofNestedMessage(value:OneofField) -> Proto3ArenaUnittest.TestAllTypes.NestedMessage? {
           switch value {
           case .OneofNestedMessage(let enumValue):
                return enumValue
           default:
                return nil
           }
      }
      case OneofString(String)

      public static func getOneofString(value:OneofField) -> String? {
           switch value {
           case .OneofString(let enumValue):
                return enumValue
           default:
                return nil
           }
      }
      case OneofBytes(NSData)

      public static func getOneofBytes(value:OneofField) -> NSData? {
           switch value {
           case .OneofBytes(let enumValue):
                return enumValue
           default:
                return nil
           }
      }
    }
    //OneOf declaration end

    private var storageOneofField:TestAllTypes.OneofField =  TestAllTypes.OneofField.OneofFieldOneOfNotSet


      //Enum type declaration start 

      public enum NestedEnum:Int32 {
        case Zero = 0
        case Foo = 1
        case Bar = 2
        case Baz = 3

        // Intentionally negative.
        case Neg = -1
        public func toString() -> String {
          switch self {
          case .Zero: return "ZERO"
          case .Foo: return "FOO"
          case .Bar: return "BAR"
          case .Baz: return "BAZ"
          case .Neg: return "NEG"
          }
        }
        public static func fromString(str:String) throws -> Proto3ArenaUnittest.TestAllTypes.NestedEnum {
          switch str {
          case "ZERO":  return .Zero
          case "FOO":  return .Foo
          case "BAR":  return .Bar
          case "BAZ":  return .Baz
          case "NEG":  return .Neg
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
      }

      //Enum type declaration end 

    // Singular
    public private(set) var hasOptionalInt32:Bool = false
    public private(set) var optionalInt32:Int32 = Int32(0)

    public private(set) var hasOptionalInt64:Bool = false
    public private(set) var optionalInt64:Int64 = Int64(0)

    public private(set) var hasOptionalUint32:Bool = false
    public private(set) var optionalUint32:UInt32 = UInt32(0)

    public private(set) var hasOptionalUint64:Bool = false
    public private(set) var optionalUint64:UInt64 = UInt64(0)

    public private(set) var hasOptionalSint32:Bool = false
    public private(set) var optionalSint32:Int32 = Int32(0)

    public private(set) var hasOptionalSint64:Bool = false
    public private(set) var optionalSint64:Int64 = Int64(0)

    public private(set) var hasOptionalFixed32:Bool = false
    public private(set) var optionalFixed32:UInt32 = UInt32(0)

    public private(set) var hasOptionalFixed64:Bool = false
    public private(set) var optionalFixed64:UInt64 = UInt64(0)

    public private(set) var hasOptionalSfixed32:Bool = false
    public private(set) var optionalSfixed32:Int32 = Int32(0)

    public private(set) var hasOptionalSfixed64:Bool = false
    public private(set) var optionalSfixed64:Int64 = Int64(0)

    public private(set) var hasOptionalFloat:Bool = false
    public private(set) var optionalFloat:Float = Float(0)

    public private(set) var hasOptionalDouble:Bool = false
    public private(set) var optionalDouble:Double = Double(0)

    public private(set) var hasOptionalBool:Bool = false
    public private(set) var optionalBool:Bool = false

    public private(set) var hasOptionalString:Bool = false
    public private(set) var optionalString:String = ""

    public private(set) var hasOptionalBytes:Bool = false
    public private(set) var optionalBytes:NSData = NSData()

    public private(set) var hasOptionalNestedMessage:Bool = false
    public private(set) var optionalNestedMessage:Proto3ArenaUnittest.TestAllTypes.NestedMessage!
    public private(set) var hasOptionalForeignMessage:Bool = false
    public private(set) var optionalForeignMessage:Proto3ArenaUnittest.ForeignMessage!
    public private(set) var hasOptionalImportMessage:Bool = false
    public private(set) var optionalImportMessage:ProtobufUnittestImport.ImportMessage!
    public private(set) var optionalNestedEnum:Proto3ArenaUnittest.TestAllTypes.NestedEnum = Proto3ArenaUnittest.TestAllTypes.NestedEnum.Zero
    public private(set) var hasOptionalNestedEnum:Bool = false
    public private(set) var optionalForeignEnum:Proto3ArenaUnittest.ForeignEnum = Proto3ArenaUnittest.ForeignEnum.ForeignZero
    public private(set) var hasOptionalForeignEnum:Bool = false
    public private(set) var hasOptionalStringPiece:Bool = false
    public private(set) var optionalStringPiece:String = ""

    public private(set) var hasOptionalCord:Bool = false
    public private(set) var optionalCord:String = ""

    public private(set) var hasOptionalPublicImportMessage:Bool = false
    public private(set) var optionalPublicImportMessage:ProtobufUnittestImport.PublicImportMessage!
    public private(set) var hasOptionalLazyMessage:Bool = false
    public private(set) var optionalLazyMessage:Proto3ArenaUnittest.TestAllTypes.NestedMessage!
    // Repeated
    public private(set) var repeatedInt32:Array<Int32> = Array<Int32>()
    public private(set) var repeatedInt64:Array<Int64> = Array<Int64>()
    public private(set) var repeatedUint32:Array<UInt32> = Array<UInt32>()
    public private(set) var repeatedUint64:Array<UInt64> = Array<UInt64>()
    public private(set) var repeatedSint32:Array<Int32> = Array<Int32>()
    public private(set) var repeatedSint64:Array<Int64> = Array<Int64>()
    public private(set) var repeatedFixed32:Array<UInt32> = Array<UInt32>()
    public private(set) var repeatedFixed64:Array<UInt64> = Array<UInt64>()
    public private(set) var repeatedSfixed32:Array<Int32> = Array<Int32>()
    public private(set) var repeatedSfixed64:Array<Int64> = Array<Int64>()
    public private(set) var repeatedFloat:Array<Float> = Array<Float>()
    public private(set) var repeatedDouble:Array<Double> = Array<Double>()
    public private(set) var repeatedBool:Array<Bool> = Array<Bool>()
    public private(set) var repeatedString:Array<String> = Array<String>()
    public private(set) var repeatedBytes:Array<NSData> = Array<NSData>()
    public private(set) var repeatedNestedMessage:Array<Proto3ArenaUnittest.TestAllTypes.NestedMessage>  = Array<Proto3ArenaUnittest.TestAllTypes.NestedMessage>()
    public private(set) var repeatedForeignMessage:Array<Proto3ArenaUnittest.ForeignMessage>  = Array<Proto3ArenaUnittest.ForeignMessage>()
    public private(set) var repeatedImportMessage:Array<ProtobufUnittestImport.ImportMessage>  = Array<ProtobufUnittestImport.ImportMessage>()
    private var repeatedNestedEnumMemoizedSerializedSize:Int32 = 0
    public private(set) var repeatedNestedEnum:Array<Proto3ArenaUnittest.TestAllTypes.NestedEnum> = Array<Proto3ArenaUnittest.TestAllTypes.NestedEnum>()
    private var repeatedForeignEnumMemoizedSerializedSize:Int32 = 0
    public private(set) var repeatedForeignEnum:Array<Proto3ArenaUnittest.ForeignEnum> = Array<Proto3ArenaUnittest.ForeignEnum>()
    public private(set) var repeatedStringPiece:Array<String> = Array<String>()
    public private(set) var repeatedCord:Array<String> = Array<String>()
    public private(set) var repeatedLazyMessage:Array<Proto3ArenaUnittest.TestAllTypes.NestedMessage>  = Array<Proto3ArenaUnittest.TestAllTypes.NestedMessage>()
    public private(set) var hasOneofUint32:Bool {
          get {
               if TestAllTypes.OneofField.getOneofUint32(storageOneofField) == nil {
                   return false
               }
               return true
          }
          set(newValue) {
          }
    }
    public private(set) var oneofUint32:UInt32!{
         get {
              return TestAllTypes.OneofField.getOneofUint32(storageOneofField)
         }
         set (newvalue) {
              storageOneofField = TestAllTypes.OneofField.OneofUint32(newvalue)
         }
    }
    public private(set) var hasOneofNestedMessage:Bool {
          get {
               if TestAllTypes.OneofField.getOneofNestedMessage(storageOneofField) == nil {
                   return false
               }
               return true
          }
          set(newValue) {
          }
    }
    public private(set) var oneofNestedMessage:Proto3ArenaUnittest.TestAllTypes.NestedMessage!{
         get {
              return TestAllTypes.OneofField.getOneofNestedMessage(storageOneofField)
         }
         set (newvalue) {
              storageOneofField = TestAllTypes.OneofField.OneofNestedMessage(newvalue)
         }
    }
    public private(set) var hasOneofString:Bool {
          get {
               if TestAllTypes.OneofField.getOneofString(storageOneofField) == nil {
                   return false
               }
               return true
          }
          set(newValue) {
          }
    }
    public private(set) var oneofString:String!{
         get {
              return TestAllTypes.OneofField.getOneofString(storageOneofField)
         }
         set (newvalue) {
              storageOneofField = TestAllTypes.OneofField.OneofString(newvalue)
         }
    }
    public private(set) var hasOneofBytes:Bool {
          get {
               if TestAllTypes.OneofField.getOneofBytes(storageOneofField) == nil {
                   return false
               }
               return true
          }
          set(newValue) {
          }
    }
    public private(set) var oneofBytes:NSData!{
         get {
              return TestAllTypes.OneofField.getOneofBytes(storageOneofField)
         }
         set (newvalue) {
              storageOneofField = TestAllTypes.OneofField.OneofBytes(newvalue)
         }
    }
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasOptionalInt32 {
        try output.writeInt32(1, value:optionalInt32)
      }
      if hasOptionalInt64 {
        try output.writeInt64(2, value:optionalInt64)
      }
      if hasOptionalUint32 {
        try output.writeUInt32(3, value:optionalUint32)
      }
      if hasOptionalUint64 {
        try output.writeUInt64(4, value:optionalUint64)
      }
      if hasOptionalSint32 {
        try output.writeSInt32(5, value:optionalSint32)
      }
      if hasOptionalSint64 {
        try output.writeSInt64(6, value:optionalSint64)
      }
      if hasOptionalFixed32 {
        try output.writeFixed32(7, value:optionalFixed32)
      }
      if hasOptionalFixed64 {
        try output.writeFixed64(8, value:optionalFixed64)
      }
      if hasOptionalSfixed32 {
        try output.writeSFixed32(9, value:optionalSfixed32)
      }
      if hasOptionalSfixed64 {
        try output.writeSFixed64(10, value:optionalSfixed64)
      }
      if hasOptionalFloat {
        try output.writeFloat(11, value:optionalFloat)
      }
      if hasOptionalDouble {
        try output.writeDouble(12, value:optionalDouble)
      }
      if hasOptionalBool {
        try output.writeBool(13, value:optionalBool)
      }
      if hasOptionalString {
        try output.writeString(14, value:optionalString)
      }
      if hasOptionalBytes {
        try output.writeData(15, value:optionalBytes)
      }
      if hasOptionalNestedMessage {
        try output.writeMessage(18, value:optionalNestedMessage)
      }
      if hasOptionalForeignMessage {
        try output.writeMessage(19, value:optionalForeignMessage)
      }
      if hasOptionalImportMessage {
        try output.writeMessage(20, value:optionalImportMessage)
      }
      if hasOptionalNestedEnum {
        try output.writeEnum(21, value:optionalNestedEnum.rawValue)
      }
      if hasOptionalForeignEnum {
        try output.writeEnum(22, value:optionalForeignEnum.rawValue)
      }
      if hasOptionalStringPiece {
        try output.writeString(24, value:optionalStringPiece)
      }
      if hasOptionalCord {
        try output.writeString(25, value:optionalCord)
      }
      if hasOptionalPublicImportMessage {
        try output.writeMessage(26, value:optionalPublicImportMessage)
      }
      if hasOptionalLazyMessage {
        try output.writeMessage(27, value:optionalLazyMessage)
      }
      if !repeatedInt32.isEmpty {
        for oneValuerepeatedInt32 in repeatedInt32 {
          try output.writeInt32(31, value:oneValuerepeatedInt32)
        }
      }
      if !repeatedInt64.isEmpty {
        for oneValuerepeatedInt64 in repeatedInt64 {
          try output.writeInt64(32, value:oneValuerepeatedInt64)
        }
      }
      if !repeatedUint32.isEmpty {
        for oneValuerepeatedUint32 in repeatedUint32 {
          try output.writeUInt32(33, value:oneValuerepeatedUint32)
        }
      }
      if !repeatedUint64.isEmpty {
        for oneValuerepeatedUint64 in repeatedUint64 {
          try output.writeUInt64(34, value:oneValuerepeatedUint64)
        }
      }
      if !repeatedSint32.isEmpty {
        for oneValuerepeatedSint32 in repeatedSint32 {
          try output.writeSInt32(35, value:oneValuerepeatedSint32)
        }
      }
      if !repeatedSint64.isEmpty {
        for oneValuerepeatedSint64 in repeatedSint64 {
          try output.writeSInt64(36, value:oneValuerepeatedSint64)
        }
      }
      if !repeatedFixed32.isEmpty {
        for oneValuerepeatedFixed32 in repeatedFixed32 {
          try output.writeFixed32(37, value:oneValuerepeatedFixed32)
        }
      }
      if !repeatedFixed64.isEmpty {
        for oneValuerepeatedFixed64 in repeatedFixed64 {
          try output.writeFixed64(38, value:oneValuerepeatedFixed64)
        }
      }
      if !repeatedSfixed32.isEmpty {
        for oneValuerepeatedSfixed32 in repeatedSfixed32 {
          try output.writeSFixed32(39, value:oneValuerepeatedSfixed32)
        }
      }
      if !repeatedSfixed64.isEmpty {
        for oneValuerepeatedSfixed64 in repeatedSfixed64 {
          try output.writeSFixed64(40, value:oneValuerepeatedSfixed64)
        }
      }
      if !repeatedFloat.isEmpty {
        for oneValuerepeatedFloat in repeatedFloat {
          try output.writeFloat(41, value:oneValuerepeatedFloat)
        }
      }
      if !repeatedDouble.isEmpty {
        for oneValuerepeatedDouble in repeatedDouble {
          try output.writeDouble(42, value:oneValuerepeatedDouble)
        }
      }
      if !repeatedBool.isEmpty {
        for oneValuerepeatedBool in repeatedBool {
          try output.writeBool(43, value:oneValuerepeatedBool)
        }
      }
      if !repeatedString.isEmpty {
        for oneValuerepeatedString in repeatedString {
          try output.writeString(44, value:oneValuerepeatedString)
        }
      }
      if !repeatedBytes.isEmpty {
        for oneValuerepeatedBytes in repeatedBytes {
          try output.writeData(45, value:oneValuerepeatedBytes)
        }
      }
      for oneElementRepeatedNestedMessage in repeatedNestedMessage {
          try output.writeMessage(48, value:oneElementRepeatedNestedMessage)
      }
      for oneElementRepeatedForeignMessage in repeatedForeignMessage {
          try output.writeMessage(49, value:oneElementRepeatedForeignMessage)
      }
      for oneElementRepeatedImportMessage in repeatedImportMessage {
          try output.writeMessage(50, value:oneElementRepeatedImportMessage)
      }
      for oneValueOfrepeatedNestedEnum in repeatedNestedEnum {
          try output.writeEnum(51, value:oneValueOfrepeatedNestedEnum.rawValue)
      }
      for oneValueOfrepeatedForeignEnum in repeatedForeignEnum {
          try output.writeEnum(52, value:oneValueOfrepeatedForeignEnum.rawValue)
      }
      if !repeatedStringPiece.isEmpty {
        for oneValuerepeatedStringPiece in repeatedStringPiece {
          try output.writeString(54, value:oneValuerepeatedStringPiece)
        }
      }
      if !repeatedCord.isEmpty {
        for oneValuerepeatedCord in repeatedCord {
          try output.writeString(55, value:oneValuerepeatedCord)
        }
      }
      for oneElementRepeatedLazyMessage in repeatedLazyMessage {
          try output.writeMessage(57, value:oneElementRepeatedLazyMessage)
      }
      if hasOneofUint32 {
        try output.writeUInt32(111, value:oneofUint32)
      }
      if hasOneofNestedMessage {
        try output.writeMessage(112, value:oneofNestedMessage)
      }
      if hasOneofString {
        try output.writeString(113, value:oneofString)
      }
      if hasOneofBytes {
        try output.writeData(114, value:oneofBytes)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasOptionalInt32 {
        serialize_size += optionalInt32.computeInt32Size(1)
      }
      if hasOptionalInt64 {
        serialize_size += optionalInt64.computeInt64Size(2)
      }
      if hasOptionalUint32 {
        serialize_size += optionalUint32.computeUInt32Size(3)
      }
      if hasOptionalUint64 {
        serialize_size += optionalUint64.computeUInt64Size(4)
      }
      if hasOptionalSint32 {
        serialize_size += optionalSint32.computeSInt32Size(5)
      }
      if hasOptionalSint64 {
        serialize_size += optionalSint64.computeSInt64Size(6)
      }
      if hasOptionalFixed32 {
        serialize_size += optionalFixed32.computeFixed32Size(7)
      }
      if hasOptionalFixed64 {
        serialize_size += optionalFixed64.computeFixed64Size(8)
      }
      if hasOptionalSfixed32 {
        serialize_size += optionalSfixed32.computeSFixed32Size(9)
      }
      if hasOptionalSfixed64 {
        serialize_size += optionalSfixed64.computeSFixed64Size(10)
      }
      if hasOptionalFloat {
        serialize_size += optionalFloat.computeFloatSize(11)
      }
      if hasOptionalDouble {
        serialize_size += optionalDouble.computeDoubleSize(12)
      }
      if hasOptionalBool {
        serialize_size += optionalBool.computeBoolSize(13)
      }
      if hasOptionalString {
        serialize_size += optionalString.computeStringSize(14)
      }
      if hasOptionalBytes {
        serialize_size += optionalBytes.computeDataSize(15)
      }
      if hasOptionalNestedMessage {
          if let varSizeoptionalNestedMessage = optionalNestedMessage?.computeMessageSize(18) {
              serialize_size += varSizeoptionalNestedMessage
          }
      }
      if hasOptionalForeignMessage {
          if let varSizeoptionalForeignMessage = optionalForeignMessage?.computeMessageSize(19) {
              serialize_size += varSizeoptionalForeignMessage
          }
      }
      if hasOptionalImportMessage {
          if let varSizeoptionalImportMessage = optionalImportMessage?.computeMessageSize(20) {
              serialize_size += varSizeoptionalImportMessage
          }
      }
      if (hasOptionalNestedEnum) {
        serialize_size += optionalNestedEnum.rawValue.computeEnumSize(21)
      }
      if (hasOptionalForeignEnum) {
        serialize_size += optionalForeignEnum.rawValue.computeEnumSize(22)
      }
      if hasOptionalStringPiece {
        serialize_size += optionalStringPiece.computeStringSize(24)
      }
      if hasOptionalCord {
        serialize_size += optionalCord.computeStringSize(25)
      }
      if hasOptionalPublicImportMessage {
          if let varSizeoptionalPublicImportMessage = optionalPublicImportMessage?.computeMessageSize(26) {
              serialize_size += varSizeoptionalPublicImportMessage
          }
      }
      if hasOptionalLazyMessage {
          if let varSizeoptionalLazyMessage = optionalLazyMessage?.computeMessageSize(27) {
              serialize_size += varSizeoptionalLazyMessage
          }
      }
      var dataSizeRepeatedInt32:Int32 = 0
      for oneValuerepeatedInt32 in repeatedInt32 {
          dataSizeRepeatedInt32 += oneValuerepeatedInt32.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeRepeatedInt32
      serialize_size += 2 * Int32(repeatedInt32.count)
      var dataSizeRepeatedInt64:Int32 = 0
      for oneValuerepeatedInt64 in repeatedInt64 {
          dataSizeRepeatedInt64 += oneValuerepeatedInt64.computeInt64SizeNoTag()
      }
      serialize_size += dataSizeRepeatedInt64
      serialize_size += 2 * Int32(repeatedInt64.count)
      var dataSizeRepeatedUint32:Int32 = 0
      for oneValuerepeatedUint32 in repeatedUint32 {
          dataSizeRepeatedUint32 += oneValuerepeatedUint32.computeUInt32SizeNoTag()
      }
      serialize_size += dataSizeRepeatedUint32
      serialize_size += 2 * Int32(repeatedUint32.count)
      var dataSizeRepeatedUint64:Int32 = 0
      for oneValuerepeatedUint64 in repeatedUint64 {
          dataSizeRepeatedUint64 += oneValuerepeatedUint64.computeUInt64SizeNoTag()
      }
      serialize_size += dataSizeRepeatedUint64
      serialize_size += 2 * Int32(repeatedUint64.count)
      var dataSizeRepeatedSint32:Int32 = 0
      for oneValuerepeatedSint32 in repeatedSint32 {
          dataSizeRepeatedSint32 += oneValuerepeatedSint32.computeSInt32SizeNoTag()
      }
      serialize_size += dataSizeRepeatedSint32
      serialize_size += 2 * Int32(repeatedSint32.count)
      var dataSizeRepeatedSint64:Int32 = 0
      for oneValuerepeatedSint64 in repeatedSint64 {
          dataSizeRepeatedSint64 += oneValuerepeatedSint64.computeSInt64SizeNoTag()
      }
      serialize_size += dataSizeRepeatedSint64
      serialize_size += 2 * Int32(repeatedSint64.count)
      var dataSizeRepeatedFixed32:Int32 = 0
      dataSizeRepeatedFixed32 = 4 * Int32(repeatedFixed32.count)
      serialize_size += dataSizeRepeatedFixed32
      serialize_size += 2 * Int32(repeatedFixed32.count)
      var dataSizeRepeatedFixed64:Int32 = 0
      dataSizeRepeatedFixed64 = 8 * Int32(repeatedFixed64.count)
      serialize_size += dataSizeRepeatedFixed64
      serialize_size += 2 * Int32(repeatedFixed64.count)
      var dataSizeRepeatedSfixed32:Int32 = 0
      dataSizeRepeatedSfixed32 = 4 * Int32(repeatedSfixed32.count)
      serialize_size += dataSizeRepeatedSfixed32
      serialize_size += 2 * Int32(repeatedSfixed32.count)
      var dataSizeRepeatedSfixed64:Int32 = 0
      dataSizeRepeatedSfixed64 = 8 * Int32(repeatedSfixed64.count)
      serialize_size += dataSizeRepeatedSfixed64
      serialize_size += 2 * Int32(repeatedSfixed64.count)
      var dataSizeRepeatedFloat:Int32 = 0
      dataSizeRepeatedFloat = 4 * Int32(repeatedFloat.count)
      serialize_size += dataSizeRepeatedFloat
      serialize_size += 2 * Int32(repeatedFloat.count)
      var dataSizeRepeatedDouble:Int32 = 0
      dataSizeRepeatedDouble = 8 * Int32(repeatedDouble.count)
      serialize_size += dataSizeRepeatedDouble
      serialize_size += 2 * Int32(repeatedDouble.count)
      var dataSizeRepeatedBool:Int32 = 0
      dataSizeRepeatedBool = 1 * Int32(repeatedBool.count)
      serialize_size += dataSizeRepeatedBool
      serialize_size += 2 * Int32(repeatedBool.count)
      var dataSizeRepeatedString:Int32 = 0
      for oneValuerepeatedString in repeatedString {
          dataSizeRepeatedString += oneValuerepeatedString.computeStringSizeNoTag()
      }
      serialize_size += dataSizeRepeatedString
      serialize_size += 2 * Int32(repeatedString.count)
      var dataSizeRepeatedBytes:Int32 = 0
      for oneValuerepeatedBytes in repeatedBytes {
          dataSizeRepeatedBytes += oneValuerepeatedBytes.computeDataSizeNoTag()
      }
      serialize_size += dataSizeRepeatedBytes
      serialize_size += 2 * Int32(repeatedBytes.count)
      for oneElementRepeatedNestedMessage in repeatedNestedMessage {
          serialize_size += oneElementRepeatedNestedMessage.computeMessageSize(48)
      }
      for oneElementRepeatedForeignMessage in repeatedForeignMessage {
          serialize_size += oneElementRepeatedForeignMessage.computeMessageSize(49)
      }
      for oneElementRepeatedImportMessage in repeatedImportMessage {
          serialize_size += oneElementRepeatedImportMessage.computeMessageSize(50)
      }
      var dataSizerepeatedNestedEnum:Int32 = 0
      for oneValueOfrepeatedNestedEnum in repeatedNestedEnum {
          dataSizerepeatedNestedEnum += oneValueOfrepeatedNestedEnum.rawValue.computeEnumSizeNoTag()
      }
      serialize_size += dataSizerepeatedNestedEnum
      serialize_size += (2 * Int32(repeatedNestedEnum.count))
      var dataSizerepeatedForeignEnum:Int32 = 0
      for oneValueOfrepeatedForeignEnum in repeatedForeignEnum {
          dataSizerepeatedForeignEnum += oneValueOfrepeatedForeignEnum.rawValue.computeEnumSizeNoTag()
      }
      serialize_size += dataSizerepeatedForeignEnum
      serialize_size += (2 * Int32(repeatedForeignEnum.count))
      var dataSizeRepeatedStringPiece:Int32 = 0
      for oneValuerepeatedStringPiece in repeatedStringPiece {
          dataSizeRepeatedStringPiece += oneValuerepeatedStringPiece.computeStringSizeNoTag()
      }
      serialize_size += dataSizeRepeatedStringPiece
      serialize_size += 2 * Int32(repeatedStringPiece.count)
      var dataSizeRepeatedCord:Int32 = 0
      for oneValuerepeatedCord in repeatedCord {
          dataSizeRepeatedCord += oneValuerepeatedCord.computeStringSizeNoTag()
      }
      serialize_size += dataSizeRepeatedCord
      serialize_size += 2 * Int32(repeatedCord.count)
      for oneElementRepeatedLazyMessage in repeatedLazyMessage {
          serialize_size += oneElementRepeatedLazyMessage.computeMessageSize(57)
      }
      if hasOneofUint32 {
        serialize_size += oneofUint32.computeUInt32Size(111)
      }
      if hasOneofNestedMessage {
          if let varSizeoneofNestedMessage = oneofNestedMessage?.computeMessageSize(112) {
              serialize_size += varSizeoneofNestedMessage
          }
      }
      if hasOneofString {
        serialize_size += oneofString.computeStringSize(113)
      }
      if hasOneofBytes {
        serialize_size += oneofBytes.computeDataSize(114)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Proto3ArenaUnittest.TestAllTypes> {
      var mergedArray = Array<Proto3ArenaUnittest.TestAllTypes>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.TestAllTypes? {
      return try Proto3ArenaUnittest.TestAllTypes.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Proto3ArenaUnittest.TestAllTypes {
      return try Proto3ArenaUnittest.TestAllTypes.Builder().mergeFromData(data, extensionRegistry:Proto3ArenaUnittest.UnittestProto3ArenaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestAllTypes {
      return try Proto3ArenaUnittest.TestAllTypes.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.TestAllTypes {
      return try Proto3ArenaUnittest.TestAllTypes.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestAllTypes {
      return try Proto3ArenaUnittest.TestAllTypes.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.TestAllTypes {
      return try Proto3ArenaUnittest.TestAllTypes.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestAllTypes {
      return try Proto3ArenaUnittest.TestAllTypes.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Proto3ArenaUnittest.TestAllTypes.Builder {
      return Proto3ArenaUnittest.TestAllTypes.classBuilder() as! Proto3ArenaUnittest.TestAllTypes.Builder
    }
    public func getBuilder() -> Proto3ArenaUnittest.TestAllTypes.Builder {
      return classBuilder() as! Proto3ArenaUnittest.TestAllTypes.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Proto3ArenaUnittest.TestAllTypes.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Proto3ArenaUnittest.TestAllTypes.Builder()
    }
    public func toBuilder() throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
      return try Proto3ArenaUnittest.TestAllTypes.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Proto3ArenaUnittest.TestAllTypes) throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
      return try Proto3ArenaUnittest.TestAllTypes.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasOptionalInt32 {
        jsonMap["optionalInt32"] = NSNumber(int:optionalInt32)
      }
      if hasOptionalInt64 {
        jsonMap["optionalInt64"] = "\(optionalInt64)"
      }
      if hasOptionalUint32 {
        jsonMap["optionalUint32"] = NSNumber(unsignedInt:optionalUint32)
      }
      if hasOptionalUint64 {
        jsonMap["optionalUint64"] = "\(optionalUint64)"
      }
      if hasOptionalSint32 {
        jsonMap["optionalSint32"] = NSNumber(int:optionalSint32)
      }
      if hasOptionalSint64 {
        jsonMap["optionalSint64"] = "\(optionalSint64)"
      }
      if hasOptionalFixed32 {
        jsonMap["optionalFixed32"] = NSNumber(unsignedInt:optionalFixed32)
      }
      if hasOptionalFixed64 {
        jsonMap["optionalFixed64"] = "\(optionalFixed64)"
      }
      if hasOptionalSfixed32 {
        jsonMap["optionalSfixed32"] = NSNumber(int:optionalSfixed32)
      }
      if hasOptionalSfixed64 {
        jsonMap["optionalSfixed64"] = "\(optionalSfixed64)"
      }
      if hasOptionalFloat {
        jsonMap["optionalFloat"] = NSNumber(float:optionalFloat)
      }
      if hasOptionalDouble {
        jsonMap["optionalDouble"] = NSNumber(double:optionalDouble)
      }
      if hasOptionalBool {
        jsonMap["optionalBool"] = optionalBool
      }
      if hasOptionalString {
        jsonMap["optionalString"] = optionalString
      }
      if hasOptionalBytes {
        jsonMap["optionalBytes"] = optionalBytes.base64EncodedStringWithOptions(NSDataBase64EncodingOptions(rawValue: 0))
      }
      if hasOptionalNestedMessage {
        jsonMap["optionalNestedMessage"] = try optionalNestedMessage.encode()
      }
      if hasOptionalForeignMessage {
        jsonMap["optionalForeignMessage"] = try optionalForeignMessage.encode()
      }
      if hasOptionalImportMessage {
        jsonMap["optionalImportMessage"] = try optionalImportMessage.encode()
      }
      if hasOptionalNestedEnum {
        jsonMap["optionalNestedEnum"] = optionalNestedEnum.toString()
      }
      if hasOptionalForeignEnum {
        jsonMap["optionalForeignEnum"] = optionalForeignEnum.toString()
      }
      if hasOptionalStringPiece {
        jsonMap["optionalStringPiece"] = optionalStringPiece
      }
      if hasOptionalCord {
        jsonMap["optionalCord"] = optionalCord
      }
      if hasOptionalPublicImportMessage {
        jsonMap["optionalPublicImportMessage"] = try optionalPublicImportMessage.encode()
      }
      if hasOptionalLazyMessage {
        jsonMap["optionalLazyMessage"] = try optionalLazyMessage.encode()
      }
      if !repeatedInt32.isEmpty {
        var jsonArrayRepeatedInt32:Array<NSNumber> = []
          for oneValueRepeatedInt32 in repeatedInt32 {
            jsonArrayRepeatedInt32 += [NSNumber(int:oneValueRepeatedInt32)]
          }
        jsonMap["repeatedInt32"] = jsonArrayRepeatedInt32
      }
      if !repeatedInt64.isEmpty {
        var jsonArrayRepeatedInt64:Array<String> = []
          for oneValueRepeatedInt64 in repeatedInt64 {
            jsonArrayRepeatedInt64 += ["\(oneValueRepeatedInt64)"]
          }
        jsonMap["repeatedInt64"] = jsonArrayRepeatedInt64
      }
      if !repeatedUint32.isEmpty {
        var jsonArrayRepeatedUint32:Array<NSNumber> = []
          for oneValueRepeatedUint32 in repeatedUint32 {
            jsonArrayRepeatedUint32 += [NSNumber(unsignedInt:oneValueRepeatedUint32)]
          }
        jsonMap["repeatedUint32"] = jsonArrayRepeatedUint32
      }
      if !repeatedUint64.isEmpty {
        var jsonArrayRepeatedUint64:Array<String> = []
          for oneValueRepeatedUint64 in repeatedUint64 {
            jsonArrayRepeatedUint64 += ["\(oneValueRepeatedUint64)"]
          }
        jsonMap["repeatedUint64"] = jsonArrayRepeatedUint64
      }
      if !repeatedSint32.isEmpty {
        var jsonArrayRepeatedSint32:Array<NSNumber> = []
          for oneValueRepeatedSint32 in repeatedSint32 {
            jsonArrayRepeatedSint32 += [NSNumber(int:oneValueRepeatedSint32)]
          }
        jsonMap["repeatedSint32"] = jsonArrayRepeatedSint32
      }
      if !repeatedSint64.isEmpty {
        var jsonArrayRepeatedSint64:Array<String> = []
          for oneValueRepeatedSint64 in repeatedSint64 {
            jsonArrayRepeatedSint64 += ["\(oneValueRepeatedSint64)"]
          }
        jsonMap["repeatedSint64"] = jsonArrayRepeatedSint64
      }
      if !repeatedFixed32.isEmpty {
        var jsonArrayRepeatedFixed32:Array<NSNumber> = []
          for oneValueRepeatedFixed32 in repeatedFixed32 {
            jsonArrayRepeatedFixed32 += [NSNumber(unsignedInt:oneValueRepeatedFixed32)]
          }
        jsonMap["repeatedFixed32"] = jsonArrayRepeatedFixed32
      }
      if !repeatedFixed64.isEmpty {
        var jsonArrayRepeatedFixed64:Array<String> = []
          for oneValueRepeatedFixed64 in repeatedFixed64 {
            jsonArrayRepeatedFixed64 += ["\(oneValueRepeatedFixed64)"]
          }
        jsonMap["repeatedFixed64"] = jsonArrayRepeatedFixed64
      }
      if !repeatedSfixed32.isEmpty {
        var jsonArrayRepeatedSfixed32:Array<NSNumber> = []
          for oneValueRepeatedSfixed32 in repeatedSfixed32 {
            jsonArrayRepeatedSfixed32 += [NSNumber(int:oneValueRepeatedSfixed32)]
          }
        jsonMap["repeatedSfixed32"] = jsonArrayRepeatedSfixed32
      }
      if !repeatedSfixed64.isEmpty {
        var jsonArrayRepeatedSfixed64:Array<String> = []
          for oneValueRepeatedSfixed64 in repeatedSfixed64 {
            jsonArrayRepeatedSfixed64 += ["\(oneValueRepeatedSfixed64)"]
          }
        jsonMap["repeatedSfixed64"] = jsonArrayRepeatedSfixed64
      }
      if !repeatedFloat.isEmpty {
        var jsonArrayRepeatedFloat:Array<NSNumber> = []
          for oneValueRepeatedFloat in repeatedFloat {
            jsonArrayRepeatedFloat += [NSNumber(float:oneValueRepeatedFloat)]
          }
        jsonMap["repeatedFloat"] = jsonArrayRepeatedFloat
      }
      if !repeatedDouble.isEmpty {
        var jsonArrayRepeatedDouble:Array<NSNumber> = []
          for oneValueRepeatedDouble in repeatedDouble {
            jsonArrayRepeatedDouble += [NSNumber(double:oneValueRepeatedDouble)]
          }
        jsonMap["repeatedDouble"] = jsonArrayRepeatedDouble
      }
      if !repeatedBool.isEmpty {
        jsonMap["repeatedBool"] = repeatedBool
      }
      if !repeatedString.isEmpty {
        jsonMap["repeatedString"] = repeatedString
      }
      if !repeatedBytes.isEmpty {
        var jsonArrayRepeatedBytes:Array<String> = []
          for oneValueRepeatedBytes in repeatedBytes {
            jsonArrayRepeatedBytes += [oneValueRepeatedBytes.base64EncodedStringWithOptions(NSDataBase64EncodingOptions(rawValue: 0))]
          }
        jsonMap["repeatedBytes"] = jsonArrayRepeatedBytes
      }
      if !repeatedNestedMessage.isEmpty {
        var jsonArrayRepeatedNestedMessage:Array<Dictionary<String,AnyObject>> = []
          for oneValueRepeatedNestedMessage in repeatedNestedMessage {
            let ecodedMessageRepeatedNestedMessage = try oneValueRepeatedNestedMessage.encode()
            jsonArrayRepeatedNestedMessage += [ecodedMessageRepeatedNestedMessage]
          }
        jsonMap["repeatedNestedMessage"] = jsonArrayRepeatedNestedMessage
      }
      if !repeatedForeignMessage.isEmpty {
        var jsonArrayRepeatedForeignMessage:Array<Dictionary<String,AnyObject>> = []
          for oneValueRepeatedForeignMessage in repeatedForeignMessage {
            let ecodedMessageRepeatedForeignMessage = try oneValueRepeatedForeignMessage.encode()
            jsonArrayRepeatedForeignMessage += [ecodedMessageRepeatedForeignMessage]
          }
        jsonMap["repeatedForeignMessage"] = jsonArrayRepeatedForeignMessage
      }
      if !repeatedImportMessage.isEmpty {
        var jsonArrayRepeatedImportMessage:Array<Dictionary<String,AnyObject>> = []
          for oneValueRepeatedImportMessage in repeatedImportMessage {
            let ecodedMessageRepeatedImportMessage = try oneValueRepeatedImportMessage.encode()
            jsonArrayRepeatedImportMessage += [ecodedMessageRepeatedImportMessage]
          }
        jsonMap["repeatedImportMessage"] = jsonArrayRepeatedImportMessage
      }
      if !repeatedNestedEnum.isEmpty {
        var jsonArrayRepeatedNestedEnum:Array<String> = []
          for oneValueRepeatedNestedEnum in repeatedNestedEnum {
            jsonArrayRepeatedNestedEnum += [oneValueRepeatedNestedEnum.toString()]
          }
        jsonMap["repeatedNestedEnum"] = jsonArrayRepeatedNestedEnum
      }
      if !repeatedForeignEnum.isEmpty {
        var jsonArrayRepeatedForeignEnum:Array<String> = []
          for oneValueRepeatedForeignEnum in repeatedForeignEnum {
            jsonArrayRepeatedForeignEnum += [oneValueRepeatedForeignEnum.toString()]
          }
        jsonMap["repeatedForeignEnum"] = jsonArrayRepeatedForeignEnum
      }
      if !repeatedStringPiece.isEmpty {
        jsonMap["repeatedStringPiece"] = repeatedStringPiece
      }
      if !repeatedCord.isEmpty {
        jsonMap["repeatedCord"] = repeatedCord
      }
      if !repeatedLazyMessage.isEmpty {
        var jsonArrayRepeatedLazyMessage:Array<Dictionary<String,AnyObject>> = []
          for oneValueRepeatedLazyMessage in repeatedLazyMessage {
            let ecodedMessageRepeatedLazyMessage = try oneValueRepeatedLazyMessage.encode()
            jsonArrayRepeatedLazyMessage += [ecodedMessageRepeatedLazyMessage]
          }
        jsonMap["repeatedLazyMessage"] = jsonArrayRepeatedLazyMessage
      }
      if hasOneofUint32 {
        jsonMap["oneofUint32"] = NSNumber(unsignedInt:oneofUint32)
      }
      if hasOneofNestedMessage {
        jsonMap["oneofNestedMessage"] = try oneofNestedMessage.encode()
      }
      if hasOneofString {
        jsonMap["oneofString"] = oneofString
      }
      if hasOneofBytes {
        jsonMap["oneofBytes"] = oneofBytes.base64EncodedStringWithOptions(NSDataBase64EncodingOptions(rawValue: 0))
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.TestAllTypes {
      return try Proto3ArenaUnittest.TestAllTypes.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Proto3ArenaUnittest.TestAllTypes {
      return try Proto3ArenaUnittest.TestAllTypes.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasOptionalInt32 {
        output += "\(indent) optionalInt32: \(optionalInt32) \n"
      }
      if hasOptionalInt64 {
        output += "\(indent) optionalInt64: \(optionalInt64) \n"
      }
      if hasOptionalUint32 {
        output += "\(indent) optionalUint32: \(optionalUint32) \n"
      }
      if hasOptionalUint64 {
        output += "\(indent) optionalUint64: \(optionalUint64) \n"
      }
      if hasOptionalSint32 {
        output += "\(indent) optionalSint32: \(optionalSint32) \n"
      }
      if hasOptionalSint64 {
        output += "\(indent) optionalSint64: \(optionalSint64) \n"
      }
      if hasOptionalFixed32 {
        output += "\(indent) optionalFixed32: \(optionalFixed32) \n"
      }
      if hasOptionalFixed64 {
        output += "\(indent) optionalFixed64: \(optionalFixed64) \n"
      }
      if hasOptionalSfixed32 {
        output += "\(indent) optionalSfixed32: \(optionalSfixed32) \n"
      }
      if hasOptionalSfixed64 {
        output += "\(indent) optionalSfixed64: \(optionalSfixed64) \n"
      }
      if hasOptionalFloat {
        output += "\(indent) optionalFloat: \(optionalFloat) \n"
      }
      if hasOptionalDouble {
        output += "\(indent) optionalDouble: \(optionalDouble) \n"
      }
      if hasOptionalBool {
        output += "\(indent) optionalBool: \(optionalBool) \n"
      }
      if hasOptionalString {
        output += "\(indent) optionalString: \(optionalString) \n"
      }
      if hasOptionalBytes {
        output += "\(indent) optionalBytes: \(optionalBytes) \n"
      }
      if hasOptionalNestedMessage {
        output += "\(indent) optionalNestedMessage {\n"
        if let outDescOptionalNestedMessage = optionalNestedMessage {
          output += try outDescOptionalNestedMessage.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasOptionalForeignMessage {
        output += "\(indent) optionalForeignMessage {\n"
        if let outDescOptionalForeignMessage = optionalForeignMessage {
          output += try outDescOptionalForeignMessage.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasOptionalImportMessage {
        output += "\(indent) optionalImportMessage {\n"
        if let outDescOptionalImportMessage = optionalImportMessage {
          output += try outDescOptionalImportMessage.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if (hasOptionalNestedEnum) {
        output += "\(indent) optionalNestedEnum: \(optionalNestedEnum.rawValue)\n"
      }
      if (hasOptionalForeignEnum) {
        output += "\(indent) optionalForeignEnum: \(optionalForeignEnum.rawValue)\n"
      }
      if hasOptionalStringPiece {
        output += "\(indent) optionalStringPiece: \(optionalStringPiece) \n"
      }
      if hasOptionalCord {
        output += "\(indent) optionalCord: \(optionalCord) \n"
      }
      if hasOptionalPublicImportMessage {
        output += "\(indent) optionalPublicImportMessage {\n"
        if let outDescOptionalPublicImportMessage = optionalPublicImportMessage {
          output += try outDescOptionalPublicImportMessage.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasOptionalLazyMessage {
        output += "\(indent) optionalLazyMessage {\n"
        if let outDescOptionalLazyMessage = optionalLazyMessage {
          output += try outDescOptionalLazyMessage.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      var repeatedInt32ElementIndex:Int = 0
      for oneValueRepeatedInt32 in repeatedInt32  {
          output += "\(indent) repeatedInt32[\(repeatedInt32ElementIndex)]: \(oneValueRepeatedInt32)\n"
          repeatedInt32ElementIndex++
      }
      var repeatedInt64ElementIndex:Int = 0
      for oneValueRepeatedInt64 in repeatedInt64  {
          output += "\(indent) repeatedInt64[\(repeatedInt64ElementIndex)]: \(oneValueRepeatedInt64)\n"
          repeatedInt64ElementIndex++
      }
      var repeatedUint32ElementIndex:Int = 0
      for oneValueRepeatedUint32 in repeatedUint32  {
          output += "\(indent) repeatedUint32[\(repeatedUint32ElementIndex)]: \(oneValueRepeatedUint32)\n"
          repeatedUint32ElementIndex++
      }
      var repeatedUint64ElementIndex:Int = 0
      for oneValueRepeatedUint64 in repeatedUint64  {
          output += "\(indent) repeatedUint64[\(repeatedUint64ElementIndex)]: \(oneValueRepeatedUint64)\n"
          repeatedUint64ElementIndex++
      }
      var repeatedSint32ElementIndex:Int = 0
      for oneValueRepeatedSint32 in repeatedSint32  {
          output += "\(indent) repeatedSint32[\(repeatedSint32ElementIndex)]: \(oneValueRepeatedSint32)\n"
          repeatedSint32ElementIndex++
      }
      var repeatedSint64ElementIndex:Int = 0
      for oneValueRepeatedSint64 in repeatedSint64  {
          output += "\(indent) repeatedSint64[\(repeatedSint64ElementIndex)]: \(oneValueRepeatedSint64)\n"
          repeatedSint64ElementIndex++
      }
      var repeatedFixed32ElementIndex:Int = 0
      for oneValueRepeatedFixed32 in repeatedFixed32  {
          output += "\(indent) repeatedFixed32[\(repeatedFixed32ElementIndex)]: \(oneValueRepeatedFixed32)\n"
          repeatedFixed32ElementIndex++
      }
      var repeatedFixed64ElementIndex:Int = 0
      for oneValueRepeatedFixed64 in repeatedFixed64  {
          output += "\(indent) repeatedFixed64[\(repeatedFixed64ElementIndex)]: \(oneValueRepeatedFixed64)\n"
          repeatedFixed64ElementIndex++
      }
      var repeatedSfixed32ElementIndex:Int = 0
      for oneValueRepeatedSfixed32 in repeatedSfixed32  {
          output += "\(indent) repeatedSfixed32[\(repeatedSfixed32ElementIndex)]: \(oneValueRepeatedSfixed32)\n"
          repeatedSfixed32ElementIndex++
      }
      var repeatedSfixed64ElementIndex:Int = 0
      for oneValueRepeatedSfixed64 in repeatedSfixed64  {
          output += "\(indent) repeatedSfixed64[\(repeatedSfixed64ElementIndex)]: \(oneValueRepeatedSfixed64)\n"
          repeatedSfixed64ElementIndex++
      }
      var repeatedFloatElementIndex:Int = 0
      for oneValueRepeatedFloat in repeatedFloat  {
          output += "\(indent) repeatedFloat[\(repeatedFloatElementIndex)]: \(oneValueRepeatedFloat)\n"
          repeatedFloatElementIndex++
      }
      var repeatedDoubleElementIndex:Int = 0
      for oneValueRepeatedDouble in repeatedDouble  {
          output += "\(indent) repeatedDouble[\(repeatedDoubleElementIndex)]: \(oneValueRepeatedDouble)\n"
          repeatedDoubleElementIndex++
      }
      var repeatedBoolElementIndex:Int = 0
      for oneValueRepeatedBool in repeatedBool  {
          output += "\(indent) repeatedBool[\(repeatedBoolElementIndex)]: \(oneValueRepeatedBool)\n"
          repeatedBoolElementIndex++
      }
      var repeatedStringElementIndex:Int = 0
      for oneValueRepeatedString in repeatedString  {
          output += "\(indent) repeatedString[\(repeatedStringElementIndex)]: \(oneValueRepeatedString)\n"
          repeatedStringElementIndex++
      }
      var repeatedBytesElementIndex:Int = 0
      for oneValueRepeatedBytes in repeatedBytes  {
          output += "\(indent) repeatedBytes[\(repeatedBytesElementIndex)]: \(oneValueRepeatedBytes)\n"
          repeatedBytesElementIndex++
      }
      var repeatedNestedMessageElementIndex:Int = 0
      for oneElementRepeatedNestedMessage in repeatedNestedMessage {
          output += "\(indent) repeatedNestedMessage[\(repeatedNestedMessageElementIndex)] {\n"
          output += try oneElementRepeatedNestedMessage.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          repeatedNestedMessageElementIndex++
      }
      var repeatedForeignMessageElementIndex:Int = 0
      for oneElementRepeatedForeignMessage in repeatedForeignMessage {
          output += "\(indent) repeatedForeignMessage[\(repeatedForeignMessageElementIndex)] {\n"
          output += try oneElementRepeatedForeignMessage.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          repeatedForeignMessageElementIndex++
      }
      var repeatedImportMessageElementIndex:Int = 0
      for oneElementRepeatedImportMessage in repeatedImportMessage {
          output += "\(indent) repeatedImportMessage[\(repeatedImportMessageElementIndex)] {\n"
          output += try oneElementRepeatedImportMessage.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          repeatedImportMessageElementIndex++
      }
      var repeatedNestedEnumElementIndex:Int = 0
      for oneValueOfrepeatedNestedEnum in repeatedNestedEnum {
          output += "\(indent) repeatedNestedEnum[\(repeatedNestedEnumElementIndex)]: \(oneValueOfrepeatedNestedEnum.rawValue)\n"
          repeatedNestedEnumElementIndex++
      }
      var repeatedForeignEnumElementIndex:Int = 0
      for oneValueOfrepeatedForeignEnum in repeatedForeignEnum {
          output += "\(indent) repeatedForeignEnum[\(repeatedForeignEnumElementIndex)]: \(oneValueOfrepeatedForeignEnum.rawValue)\n"
          repeatedForeignEnumElementIndex++
      }
      var repeatedStringPieceElementIndex:Int = 0
      for oneValueRepeatedStringPiece in repeatedStringPiece  {
          output += "\(indent) repeatedStringPiece[\(repeatedStringPieceElementIndex)]: \(oneValueRepeatedStringPiece)\n"
          repeatedStringPieceElementIndex++
      }
      var repeatedCordElementIndex:Int = 0
      for oneValueRepeatedCord in repeatedCord  {
          output += "\(indent) repeatedCord[\(repeatedCordElementIndex)]: \(oneValueRepeatedCord)\n"
          repeatedCordElementIndex++
      }
      var repeatedLazyMessageElementIndex:Int = 0
      for oneElementRepeatedLazyMessage in repeatedLazyMessage {
          output += "\(indent) repeatedLazyMessage[\(repeatedLazyMessageElementIndex)] {\n"
          output += try oneElementRepeatedLazyMessage.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          repeatedLazyMessageElementIndex++
      }
      if hasOneofUint32 {
        output += "\(indent) oneofUint32: \(oneofUint32) \n"
      }
      if hasOneofNestedMessage {
        output += "\(indent) oneofNestedMessage {\n"
        if let outDescOneofNestedMessage = oneofNestedMessage {
          output += try outDescOneofNestedMessage.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasOneofString {
        output += "\(indent) oneofString: \(oneofString) \n"
      }
      if hasOneofBytes {
        output += "\(indent) oneofBytes: \(oneofBytes) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasOptionalInt32 {
               hashCode = (hashCode &* 31) &+ optionalInt32.hashValue
            }
            if hasOptionalInt64 {
               hashCode = (hashCode &* 31) &+ optionalInt64.hashValue
            }
            if hasOptionalUint32 {
               hashCode = (hashCode &* 31) &+ optionalUint32.hashValue
            }
            if hasOptionalUint64 {
               hashCode = (hashCode &* 31) &+ optionalUint64.hashValue
            }
            if hasOptionalSint32 {
               hashCode = (hashCode &* 31) &+ optionalSint32.hashValue
            }
            if hasOptionalSint64 {
               hashCode = (hashCode &* 31) &+ optionalSint64.hashValue
            }
            if hasOptionalFixed32 {
               hashCode = (hashCode &* 31) &+ optionalFixed32.hashValue
            }
            if hasOptionalFixed64 {
               hashCode = (hashCode &* 31) &+ optionalFixed64.hashValue
            }
            if hasOptionalSfixed32 {
               hashCode = (hashCode &* 31) &+ optionalSfixed32.hashValue
            }
            if hasOptionalSfixed64 {
               hashCode = (hashCode &* 31) &+ optionalSfixed64.hashValue
            }
            if hasOptionalFloat {
               hashCode = (hashCode &* 31) &+ optionalFloat.hashValue
            }
            if hasOptionalDouble {
               hashCode = (hashCode &* 31) &+ optionalDouble.hashValue
            }
            if hasOptionalBool {
               hashCode = (hashCode &* 31) &+ optionalBool.hashValue
            }
            if hasOptionalString {
               hashCode = (hashCode &* 31) &+ optionalString.hashValue
            }
            if hasOptionalBytes {
               hashCode = (hashCode &* 31) &+ optionalBytes.hashValue
            }
            if hasOptionalNestedMessage {
                if let hashValueoptionalNestedMessage = optionalNestedMessage?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptionalNestedMessage
                }
            }
            if hasOptionalForeignMessage {
                if let hashValueoptionalForeignMessage = optionalForeignMessage?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptionalForeignMessage
                }
            }
            if hasOptionalImportMessage {
                if let hashValueoptionalImportMessage = optionalImportMessage?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptionalImportMessage
                }
            }
            if hasOptionalNestedEnum {
               hashCode = (hashCode &* 31) &+ Int(optionalNestedEnum.rawValue)
            }
            if hasOptionalForeignEnum {
               hashCode = (hashCode &* 31) &+ Int(optionalForeignEnum.rawValue)
            }
            if hasOptionalStringPiece {
               hashCode = (hashCode &* 31) &+ optionalStringPiece.hashValue
            }
            if hasOptionalCord {
               hashCode = (hashCode &* 31) &+ optionalCord.hashValue
            }
            if hasOptionalPublicImportMessage {
                if let hashValueoptionalPublicImportMessage = optionalPublicImportMessage?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptionalPublicImportMessage
                }
            }
            if hasOptionalLazyMessage {
                if let hashValueoptionalLazyMessage = optionalLazyMessage?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptionalLazyMessage
                }
            }
            for oneValueRepeatedInt32 in repeatedInt32 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedInt32.hashValue
            }
            for oneValueRepeatedInt64 in repeatedInt64 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedInt64.hashValue
            }
            for oneValueRepeatedUint32 in repeatedUint32 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedUint32.hashValue
            }
            for oneValueRepeatedUint64 in repeatedUint64 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedUint64.hashValue
            }
            for oneValueRepeatedSint32 in repeatedSint32 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedSint32.hashValue
            }
            for oneValueRepeatedSint64 in repeatedSint64 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedSint64.hashValue
            }
            for oneValueRepeatedFixed32 in repeatedFixed32 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedFixed32.hashValue
            }
            for oneValueRepeatedFixed64 in repeatedFixed64 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedFixed64.hashValue
            }
            for oneValueRepeatedSfixed32 in repeatedSfixed32 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedSfixed32.hashValue
            }
            for oneValueRepeatedSfixed64 in repeatedSfixed64 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedSfixed64.hashValue
            }
            for oneValueRepeatedFloat in repeatedFloat {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedFloat.hashValue
            }
            for oneValueRepeatedDouble in repeatedDouble {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedDouble.hashValue
            }
            for oneValueRepeatedBool in repeatedBool {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedBool.hashValue
            }
            for oneValueRepeatedString in repeatedString {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedString.hashValue
            }
            for oneValueRepeatedBytes in repeatedBytes {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedBytes.hashValue
            }
            for oneElementRepeatedNestedMessage in repeatedNestedMessage {
                hashCode = (hashCode &* 31) &+ oneElementRepeatedNestedMessage.hashValue
            }
            for oneElementRepeatedForeignMessage in repeatedForeignMessage {
                hashCode = (hashCode &* 31) &+ oneElementRepeatedForeignMessage.hashValue
            }
            for oneElementRepeatedImportMessage in repeatedImportMessage {
                hashCode = (hashCode &* 31) &+ oneElementRepeatedImportMessage.hashValue
            }
            for oneValueOfrepeatedNestedEnum in repeatedNestedEnum {
                hashCode = (hashCode &* 31) &+ Int(oneValueOfrepeatedNestedEnum.rawValue)
            }
            for oneValueOfrepeatedForeignEnum in repeatedForeignEnum {
                hashCode = (hashCode &* 31) &+ Int(oneValueOfrepeatedForeignEnum.rawValue)
            }
            for oneValueRepeatedStringPiece in repeatedStringPiece {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedStringPiece.hashValue
            }
            for oneValueRepeatedCord in repeatedCord {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedCord.hashValue
            }
            for oneElementRepeatedLazyMessage in repeatedLazyMessage {
                hashCode = (hashCode &* 31) &+ oneElementRepeatedLazyMessage.hashValue
            }
            if hasOneofUint32 {
               hashCode = (hashCode &* 31) &+ oneofUint32.hashValue
            }
            if hasOneofNestedMessage {
                if let hashValueoneofNestedMessage = oneofNestedMessage?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoneofNestedMessage
                }
            }
            if hasOneofString {
               hashCode = (hashCode &* 31) &+ oneofString.hashValue
            }
            if hasOneofBytes {
               hashCode = (hashCode &* 31) &+ oneofBytes.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Proto3ArenaUnittest.TestAllTypes"
    }
    override public func className() -> String {
        return "Proto3ArenaUnittest.TestAllTypes"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Proto3ArenaUnittest.TestAllTypes.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Proto3ArenaUnittest.TestAllTypes = Proto3ArenaUnittest.TestAllTypes()
      public func getMessage() -> Proto3ArenaUnittest.TestAllTypes {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasOptionalInt32:Bool {
           get {
                return builderResult.hasOptionalInt32
           }
      }
      public var optionalInt32:Int32 {
           get {
                return builderResult.optionalInt32
           }
           set (value) {
               builderResult.hasOptionalInt32 = true
               builderResult.optionalInt32 = value
           }
      }
      public func setOptionalInt32(value:Int32) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalInt32 = value
        return self
      }
      public func clearOptionalInt32() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalInt32 = false
           builderResult.optionalInt32 = Int32(0)
           return self
      }
      public var hasOptionalInt64:Bool {
           get {
                return builderResult.hasOptionalInt64
           }
      }
      public var optionalInt64:Int64 {
           get {
                return builderResult.optionalInt64
           }
           set (value) {
               builderResult.hasOptionalInt64 = true
               builderResult.optionalInt64 = value
           }
      }
      public func setOptionalInt64(value:Int64) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalInt64 = value
        return self
      }
      public func clearOptionalInt64() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalInt64 = false
           builderResult.optionalInt64 = Int64(0)
           return self
      }
      public var hasOptionalUint32:Bool {
           get {
                return builderResult.hasOptionalUint32
           }
      }
      public var optionalUint32:UInt32 {
           get {
                return builderResult.optionalUint32
           }
           set (value) {
               builderResult.hasOptionalUint32 = true
               builderResult.optionalUint32 = value
           }
      }
      public func setOptionalUint32(value:UInt32) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalUint32 = value
        return self
      }
      public func clearOptionalUint32() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalUint32 = false
           builderResult.optionalUint32 = UInt32(0)
           return self
      }
      public var hasOptionalUint64:Bool {
           get {
                return builderResult.hasOptionalUint64
           }
      }
      public var optionalUint64:UInt64 {
           get {
                return builderResult.optionalUint64
           }
           set (value) {
               builderResult.hasOptionalUint64 = true
               builderResult.optionalUint64 = value
           }
      }
      public func setOptionalUint64(value:UInt64) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalUint64 = value
        return self
      }
      public func clearOptionalUint64() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalUint64 = false
           builderResult.optionalUint64 = UInt64(0)
           return self
      }
      public var hasOptionalSint32:Bool {
           get {
                return builderResult.hasOptionalSint32
           }
      }
      public var optionalSint32:Int32 {
           get {
                return builderResult.optionalSint32
           }
           set (value) {
               builderResult.hasOptionalSint32 = true
               builderResult.optionalSint32 = value
           }
      }
      public func setOptionalSint32(value:Int32) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalSint32 = value
        return self
      }
      public func clearOptionalSint32() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalSint32 = false
           builderResult.optionalSint32 = Int32(0)
           return self
      }
      public var hasOptionalSint64:Bool {
           get {
                return builderResult.hasOptionalSint64
           }
      }
      public var optionalSint64:Int64 {
           get {
                return builderResult.optionalSint64
           }
           set (value) {
               builderResult.hasOptionalSint64 = true
               builderResult.optionalSint64 = value
           }
      }
      public func setOptionalSint64(value:Int64) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalSint64 = value
        return self
      }
      public func clearOptionalSint64() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalSint64 = false
           builderResult.optionalSint64 = Int64(0)
           return self
      }
      public var hasOptionalFixed32:Bool {
           get {
                return builderResult.hasOptionalFixed32
           }
      }
      public var optionalFixed32:UInt32 {
           get {
                return builderResult.optionalFixed32
           }
           set (value) {
               builderResult.hasOptionalFixed32 = true
               builderResult.optionalFixed32 = value
           }
      }
      public func setOptionalFixed32(value:UInt32) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalFixed32 = value
        return self
      }
      public func clearOptionalFixed32() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalFixed32 = false
           builderResult.optionalFixed32 = UInt32(0)
           return self
      }
      public var hasOptionalFixed64:Bool {
           get {
                return builderResult.hasOptionalFixed64
           }
      }
      public var optionalFixed64:UInt64 {
           get {
                return builderResult.optionalFixed64
           }
           set (value) {
               builderResult.hasOptionalFixed64 = true
               builderResult.optionalFixed64 = value
           }
      }
      public func setOptionalFixed64(value:UInt64) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalFixed64 = value
        return self
      }
      public func clearOptionalFixed64() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalFixed64 = false
           builderResult.optionalFixed64 = UInt64(0)
           return self
      }
      public var hasOptionalSfixed32:Bool {
           get {
                return builderResult.hasOptionalSfixed32
           }
      }
      public var optionalSfixed32:Int32 {
           get {
                return builderResult.optionalSfixed32
           }
           set (value) {
               builderResult.hasOptionalSfixed32 = true
               builderResult.optionalSfixed32 = value
           }
      }
      public func setOptionalSfixed32(value:Int32) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalSfixed32 = value
        return self
      }
      public func clearOptionalSfixed32() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalSfixed32 = false
           builderResult.optionalSfixed32 = Int32(0)
           return self
      }
      public var hasOptionalSfixed64:Bool {
           get {
                return builderResult.hasOptionalSfixed64
           }
      }
      public var optionalSfixed64:Int64 {
           get {
                return builderResult.optionalSfixed64
           }
           set (value) {
               builderResult.hasOptionalSfixed64 = true
               builderResult.optionalSfixed64 = value
           }
      }
      public func setOptionalSfixed64(value:Int64) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalSfixed64 = value
        return self
      }
      public func clearOptionalSfixed64() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalSfixed64 = false
           builderResult.optionalSfixed64 = Int64(0)
           return self
      }
      public var hasOptionalFloat:Bool {
           get {
                return builderResult.hasOptionalFloat
           }
      }
      public var optionalFloat:Float {
           get {
                return builderResult.optionalFloat
           }
           set (value) {
               builderResult.hasOptionalFloat = true
               builderResult.optionalFloat = value
           }
      }
      public func setOptionalFloat(value:Float) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalFloat = value
        return self
      }
      public func clearOptionalFloat() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalFloat = false
           builderResult.optionalFloat = Float(0)
           return self
      }
      public var hasOptionalDouble:Bool {
           get {
                return builderResult.hasOptionalDouble
           }
      }
      public var optionalDouble:Double {
           get {
                return builderResult.optionalDouble
           }
           set (value) {
               builderResult.hasOptionalDouble = true
               builderResult.optionalDouble = value
           }
      }
      public func setOptionalDouble(value:Double) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalDouble = value
        return self
      }
      public func clearOptionalDouble() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalDouble = false
           builderResult.optionalDouble = Double(0)
           return self
      }
      public var hasOptionalBool:Bool {
           get {
                return builderResult.hasOptionalBool
           }
      }
      public var optionalBool:Bool {
           get {
                return builderResult.optionalBool
           }
           set (value) {
               builderResult.hasOptionalBool = true
               builderResult.optionalBool = value
           }
      }
      public func setOptionalBool(value:Bool) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalBool = value
        return self
      }
      public func clearOptionalBool() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalBool = false
           builderResult.optionalBool = false
           return self
      }
      public var hasOptionalString:Bool {
           get {
                return builderResult.hasOptionalString
           }
      }
      public var optionalString:String {
           get {
                return builderResult.optionalString
           }
           set (value) {
               builderResult.hasOptionalString = true
               builderResult.optionalString = value
           }
      }
      public func setOptionalString(value:String) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalString = value
        return self
      }
      public func clearOptionalString() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalString = false
           builderResult.optionalString = ""
           return self
      }
      public var hasOptionalBytes:Bool {
           get {
                return builderResult.hasOptionalBytes
           }
      }
      public var optionalBytes:NSData {
           get {
                return builderResult.optionalBytes
           }
           set (value) {
               builderResult.hasOptionalBytes = true
               builderResult.optionalBytes = value
           }
      }
      public func setOptionalBytes(value:NSData) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalBytes = value
        return self
      }
      public func clearOptionalBytes() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalBytes = false
           builderResult.optionalBytes = NSData()
           return self
      }
      public var hasOptionalNestedMessage:Bool {
           get {
               return builderResult.hasOptionalNestedMessage
           }
      }
      public var optionalNestedMessage:Proto3ArenaUnittest.TestAllTypes.NestedMessage! {
           get {
               if optionalNestedMessageBuilder_ != nil {
                  builderResult.optionalNestedMessage = optionalNestedMessageBuilder_.getMessage()
               }
               return builderResult.optionalNestedMessage
           }
           set (value) {
               builderResult.hasOptionalNestedMessage = true
               builderResult.optionalNestedMessage = value
           }
      }
      private var optionalNestedMessageBuilder_:Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder! {
           didSet {
              builderResult.hasOptionalNestedMessage = true
           }
      }
      public func getOptionalNestedMessageBuilder() -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
        if optionalNestedMessageBuilder_ == nil {
           optionalNestedMessageBuilder_ = Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder()
           builderResult.optionalNestedMessage = optionalNestedMessageBuilder_.getMessage()
           if optionalNestedMessage != nil {
              try! optionalNestedMessageBuilder_.mergeFrom(optionalNestedMessage)
           }
        }
        return optionalNestedMessageBuilder_
      }
      public func setOptionalNestedMessage(value:Proto3ArenaUnittest.TestAllTypes.NestedMessage!) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalNestedMessage = value
        return self
      }
      public func mergeOptionalNestedMessage(value:Proto3ArenaUnittest.TestAllTypes.NestedMessage) throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
        if builderResult.hasOptionalNestedMessage {
          builderResult.optionalNestedMessage = try Proto3ArenaUnittest.TestAllTypes.NestedMessage.builderWithPrototype(builderResult.optionalNestedMessage).mergeFrom(value).buildPartial()
        } else {
          builderResult.optionalNestedMessage = value
        }
        builderResult.hasOptionalNestedMessage = true
        return self
      }
      public func clearOptionalNestedMessage() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        optionalNestedMessageBuilder_ = nil
        builderResult.hasOptionalNestedMessage = false
        builderResult.optionalNestedMessage = nil
        return self
      }
      public var hasOptionalForeignMessage:Bool {
           get {
               return builderResult.hasOptionalForeignMessage
           }
      }
      public var optionalForeignMessage:Proto3ArenaUnittest.ForeignMessage! {
           get {
               if optionalForeignMessageBuilder_ != nil {
                  builderResult.optionalForeignMessage = optionalForeignMessageBuilder_.getMessage()
               }
               return builderResult.optionalForeignMessage
           }
           set (value) {
               builderResult.hasOptionalForeignMessage = true
               builderResult.optionalForeignMessage = value
           }
      }
      private var optionalForeignMessageBuilder_:Proto3ArenaUnittest.ForeignMessage.Builder! {
           didSet {
              builderResult.hasOptionalForeignMessage = true
           }
      }
      public func getOptionalForeignMessageBuilder() -> Proto3ArenaUnittest.ForeignMessage.Builder {
        if optionalForeignMessageBuilder_ == nil {
           optionalForeignMessageBuilder_ = Proto3ArenaUnittest.ForeignMessage.Builder()
           builderResult.optionalForeignMessage = optionalForeignMessageBuilder_.getMessage()
           if optionalForeignMessage != nil {
              try! optionalForeignMessageBuilder_.mergeFrom(optionalForeignMessage)
           }
        }
        return optionalForeignMessageBuilder_
      }
      public func setOptionalForeignMessage(value:Proto3ArenaUnittest.ForeignMessage!) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalForeignMessage = value
        return self
      }
      public func mergeOptionalForeignMessage(value:Proto3ArenaUnittest.ForeignMessage) throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
        if builderResult.hasOptionalForeignMessage {
          builderResult.optionalForeignMessage = try Proto3ArenaUnittest.ForeignMessage.builderWithPrototype(builderResult.optionalForeignMessage).mergeFrom(value).buildPartial()
        } else {
          builderResult.optionalForeignMessage = value
        }
        builderResult.hasOptionalForeignMessage = true
        return self
      }
      public func clearOptionalForeignMessage() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        optionalForeignMessageBuilder_ = nil
        builderResult.hasOptionalForeignMessage = false
        builderResult.optionalForeignMessage = nil
        return self
      }
      public var hasOptionalImportMessage:Bool {
           get {
               return builderResult.hasOptionalImportMessage
           }
      }
      public var optionalImportMessage:ProtobufUnittestImport.ImportMessage! {
           get {
               if optionalImportMessageBuilder_ != nil {
                  builderResult.optionalImportMessage = optionalImportMessageBuilder_.getMessage()
               }
               return builderResult.optionalImportMessage
           }
           set (value) {
               builderResult.hasOptionalImportMessage = true
               builderResult.optionalImportMessage = value
           }
      }
      private var optionalImportMessageBuilder_:ProtobufUnittestImport.ImportMessage.Builder! {
           didSet {
              builderResult.hasOptionalImportMessage = true
           }
      }
      public func getOptionalImportMessageBuilder() -> ProtobufUnittestImport.ImportMessage.Builder {
        if optionalImportMessageBuilder_ == nil {
           optionalImportMessageBuilder_ = ProtobufUnittestImport.ImportMessage.Builder()
           builderResult.optionalImportMessage = optionalImportMessageBuilder_.getMessage()
           if optionalImportMessage != nil {
              try! optionalImportMessageBuilder_.mergeFrom(optionalImportMessage)
           }
        }
        return optionalImportMessageBuilder_
      }
      public func setOptionalImportMessage(value:ProtobufUnittestImport.ImportMessage!) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalImportMessage = value
        return self
      }
      public func mergeOptionalImportMessage(value:ProtobufUnittestImport.ImportMessage) throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
        if builderResult.hasOptionalImportMessage {
          builderResult.optionalImportMessage = try ProtobufUnittestImport.ImportMessage.builderWithPrototype(builderResult.optionalImportMessage).mergeFrom(value).buildPartial()
        } else {
          builderResult.optionalImportMessage = value
        }
        builderResult.hasOptionalImportMessage = true
        return self
      }
      public func clearOptionalImportMessage() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        optionalImportMessageBuilder_ = nil
        builderResult.hasOptionalImportMessage = false
        builderResult.optionalImportMessage = nil
        return self
      }
        public var hasOptionalNestedEnum:Bool{
            get {
                return builderResult.hasOptionalNestedEnum
            }
        }
        public var optionalNestedEnum:Proto3ArenaUnittest.TestAllTypes.NestedEnum {
            get {
                return builderResult.optionalNestedEnum
            }
            set (value) {
                builderResult.hasOptionalNestedEnum = true
                builderResult.optionalNestedEnum = value
            }
        }
        public func setOptionalNestedEnum(value:Proto3ArenaUnittest.TestAllTypes.NestedEnum) -> Proto3ArenaUnittest.TestAllTypes.Builder {
          self.optionalNestedEnum = value
          return self
        }
        public func clearOptionalNestedEnum() -> Proto3ArenaUnittest.TestAllTypes.Builder {
           builderResult.hasOptionalNestedEnum = false
           builderResult.optionalNestedEnum = .Zero
           return self
        }
        public var hasOptionalForeignEnum:Bool{
            get {
                return builderResult.hasOptionalForeignEnum
            }
        }
        public var optionalForeignEnum:Proto3ArenaUnittest.ForeignEnum {
            get {
                return builderResult.optionalForeignEnum
            }
            set (value) {
                builderResult.hasOptionalForeignEnum = true
                builderResult.optionalForeignEnum = value
            }
        }
        public func setOptionalForeignEnum(value:Proto3ArenaUnittest.ForeignEnum) -> Proto3ArenaUnittest.TestAllTypes.Builder {
          self.optionalForeignEnum = value
          return self
        }
        public func clearOptionalForeignEnum() -> Proto3ArenaUnittest.TestAllTypes.Builder {
           builderResult.hasOptionalForeignEnum = false
           builderResult.optionalForeignEnum = .ForeignZero
           return self
        }
      public var hasOptionalStringPiece:Bool {
           get {
                return builderResult.hasOptionalStringPiece
           }
      }
      public var optionalStringPiece:String {
           get {
                return builderResult.optionalStringPiece
           }
           set (value) {
               builderResult.hasOptionalStringPiece = true
               builderResult.optionalStringPiece = value
           }
      }
      public func setOptionalStringPiece(value:String) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalStringPiece = value
        return self
      }
      public func clearOptionalStringPiece() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalStringPiece = false
           builderResult.optionalStringPiece = ""
           return self
      }
      public var hasOptionalCord:Bool {
           get {
                return builderResult.hasOptionalCord
           }
      }
      public var optionalCord:String {
           get {
                return builderResult.optionalCord
           }
           set (value) {
               builderResult.hasOptionalCord = true
               builderResult.optionalCord = value
           }
      }
      public func setOptionalCord(value:String) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalCord = value
        return self
      }
      public func clearOptionalCord() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOptionalCord = false
           builderResult.optionalCord = ""
           return self
      }
      public var hasOptionalPublicImportMessage:Bool {
           get {
               return builderResult.hasOptionalPublicImportMessage
           }
      }
      public var optionalPublicImportMessage:ProtobufUnittestImport.PublicImportMessage! {
           get {
               if optionalPublicImportMessageBuilder_ != nil {
                  builderResult.optionalPublicImportMessage = optionalPublicImportMessageBuilder_.getMessage()
               }
               return builderResult.optionalPublicImportMessage
           }
           set (value) {
               builderResult.hasOptionalPublicImportMessage = true
               builderResult.optionalPublicImportMessage = value
           }
      }
      private var optionalPublicImportMessageBuilder_:ProtobufUnittestImport.PublicImportMessage.Builder! {
           didSet {
              builderResult.hasOptionalPublicImportMessage = true
           }
      }
      public func getOptionalPublicImportMessageBuilder() -> ProtobufUnittestImport.PublicImportMessage.Builder {
        if optionalPublicImportMessageBuilder_ == nil {
           optionalPublicImportMessageBuilder_ = ProtobufUnittestImport.PublicImportMessage.Builder()
           builderResult.optionalPublicImportMessage = optionalPublicImportMessageBuilder_.getMessage()
           if optionalPublicImportMessage != nil {
              try! optionalPublicImportMessageBuilder_.mergeFrom(optionalPublicImportMessage)
           }
        }
        return optionalPublicImportMessageBuilder_
      }
      public func setOptionalPublicImportMessage(value:ProtobufUnittestImport.PublicImportMessage!) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalPublicImportMessage = value
        return self
      }
      public func mergeOptionalPublicImportMessage(value:ProtobufUnittestImport.PublicImportMessage) throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
        if builderResult.hasOptionalPublicImportMessage {
          builderResult.optionalPublicImportMessage = try ProtobufUnittestImport.PublicImportMessage.builderWithPrototype(builderResult.optionalPublicImportMessage).mergeFrom(value).buildPartial()
        } else {
          builderResult.optionalPublicImportMessage = value
        }
        builderResult.hasOptionalPublicImportMessage = true
        return self
      }
      public func clearOptionalPublicImportMessage() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        optionalPublicImportMessageBuilder_ = nil
        builderResult.hasOptionalPublicImportMessage = false
        builderResult.optionalPublicImportMessage = nil
        return self
      }
      public var hasOptionalLazyMessage:Bool {
           get {
               return builderResult.hasOptionalLazyMessage
           }
      }
      public var optionalLazyMessage:Proto3ArenaUnittest.TestAllTypes.NestedMessage! {
           get {
               if optionalLazyMessageBuilder_ != nil {
                  builderResult.optionalLazyMessage = optionalLazyMessageBuilder_.getMessage()
               }
               return builderResult.optionalLazyMessage
           }
           set (value) {
               builderResult.hasOptionalLazyMessage = true
               builderResult.optionalLazyMessage = value
           }
      }
      private var optionalLazyMessageBuilder_:Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder! {
           didSet {
              builderResult.hasOptionalLazyMessage = true
           }
      }
      public func getOptionalLazyMessageBuilder() -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
        if optionalLazyMessageBuilder_ == nil {
           optionalLazyMessageBuilder_ = Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder()
           builderResult.optionalLazyMessage = optionalLazyMessageBuilder_.getMessage()
           if optionalLazyMessage != nil {
              try! optionalLazyMessageBuilder_.mergeFrom(optionalLazyMessage)
           }
        }
        return optionalLazyMessageBuilder_
      }
      public func setOptionalLazyMessage(value:Proto3ArenaUnittest.TestAllTypes.NestedMessage!) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.optionalLazyMessage = value
        return self
      }
      public func mergeOptionalLazyMessage(value:Proto3ArenaUnittest.TestAllTypes.NestedMessage) throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
        if builderResult.hasOptionalLazyMessage {
          builderResult.optionalLazyMessage = try Proto3ArenaUnittest.TestAllTypes.NestedMessage.builderWithPrototype(builderResult.optionalLazyMessage).mergeFrom(value).buildPartial()
        } else {
          builderResult.optionalLazyMessage = value
        }
        builderResult.hasOptionalLazyMessage = true
        return self
      }
      public func clearOptionalLazyMessage() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        optionalLazyMessageBuilder_ = nil
        builderResult.hasOptionalLazyMessage = false
        builderResult.optionalLazyMessage = nil
        return self
      }
      public var repeatedInt32:Array<Int32> {
           get {
               return builderResult.repeatedInt32
           }
           set (array) {
               builderResult.repeatedInt32 = array
           }
      }
      public func setRepeatedInt32(value:Array<Int32>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedInt32 = value
        return self
      }
      public func clearRepeatedInt32() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedInt32.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedInt64:Array<Int64> {
           get {
               return builderResult.repeatedInt64
           }
           set (array) {
               builderResult.repeatedInt64 = array
           }
      }
      public func setRepeatedInt64(value:Array<Int64>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedInt64 = value
        return self
      }
      public func clearRepeatedInt64() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedInt64.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedUint32:Array<UInt32> {
           get {
               return builderResult.repeatedUint32
           }
           set (array) {
               builderResult.repeatedUint32 = array
           }
      }
      public func setRepeatedUint32(value:Array<UInt32>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedUint32 = value
        return self
      }
      public func clearRepeatedUint32() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedUint32.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedUint64:Array<UInt64> {
           get {
               return builderResult.repeatedUint64
           }
           set (array) {
               builderResult.repeatedUint64 = array
           }
      }
      public func setRepeatedUint64(value:Array<UInt64>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedUint64 = value
        return self
      }
      public func clearRepeatedUint64() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedUint64.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedSint32:Array<Int32> {
           get {
               return builderResult.repeatedSint32
           }
           set (array) {
               builderResult.repeatedSint32 = array
           }
      }
      public func setRepeatedSint32(value:Array<Int32>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedSint32 = value
        return self
      }
      public func clearRepeatedSint32() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedSint32.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedSint64:Array<Int64> {
           get {
               return builderResult.repeatedSint64
           }
           set (array) {
               builderResult.repeatedSint64 = array
           }
      }
      public func setRepeatedSint64(value:Array<Int64>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedSint64 = value
        return self
      }
      public func clearRepeatedSint64() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedSint64.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedFixed32:Array<UInt32> {
           get {
               return builderResult.repeatedFixed32
           }
           set (array) {
               builderResult.repeatedFixed32 = array
           }
      }
      public func setRepeatedFixed32(value:Array<UInt32>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedFixed32 = value
        return self
      }
      public func clearRepeatedFixed32() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedFixed32.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedFixed64:Array<UInt64> {
           get {
               return builderResult.repeatedFixed64
           }
           set (array) {
               builderResult.repeatedFixed64 = array
           }
      }
      public func setRepeatedFixed64(value:Array<UInt64>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedFixed64 = value
        return self
      }
      public func clearRepeatedFixed64() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedFixed64.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedSfixed32:Array<Int32> {
           get {
               return builderResult.repeatedSfixed32
           }
           set (array) {
               builderResult.repeatedSfixed32 = array
           }
      }
      public func setRepeatedSfixed32(value:Array<Int32>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedSfixed32 = value
        return self
      }
      public func clearRepeatedSfixed32() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedSfixed32.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedSfixed64:Array<Int64> {
           get {
               return builderResult.repeatedSfixed64
           }
           set (array) {
               builderResult.repeatedSfixed64 = array
           }
      }
      public func setRepeatedSfixed64(value:Array<Int64>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedSfixed64 = value
        return self
      }
      public func clearRepeatedSfixed64() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedSfixed64.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedFloat:Array<Float> {
           get {
               return builderResult.repeatedFloat
           }
           set (array) {
               builderResult.repeatedFloat = array
           }
      }
      public func setRepeatedFloat(value:Array<Float>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedFloat = value
        return self
      }
      public func clearRepeatedFloat() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedFloat.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedDouble:Array<Double> {
           get {
               return builderResult.repeatedDouble
           }
           set (array) {
               builderResult.repeatedDouble = array
           }
      }
      public func setRepeatedDouble(value:Array<Double>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedDouble = value
        return self
      }
      public func clearRepeatedDouble() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedDouble.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedBool:Array<Bool> {
           get {
               return builderResult.repeatedBool
           }
           set (array) {
               builderResult.repeatedBool = array
           }
      }
      public func setRepeatedBool(value:Array<Bool>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedBool = value
        return self
      }
      public func clearRepeatedBool() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedBool.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedString:Array<String> {
           get {
               return builderResult.repeatedString
           }
           set (array) {
               builderResult.repeatedString = array
           }
      }
      public func setRepeatedString(value:Array<String>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedString = value
        return self
      }
      public func clearRepeatedString() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedString.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedBytes:Array<NSData> {
           get {
               return builderResult.repeatedBytes
           }
           set (array) {
               builderResult.repeatedBytes = array
           }
      }
      public func setRepeatedBytes(value:Array<NSData>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedBytes = value
        return self
      }
      public func clearRepeatedBytes() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedBytes.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedNestedMessage:Array<Proto3ArenaUnittest.TestAllTypes.NestedMessage> {
           get {
               return builderResult.repeatedNestedMessage
           }
           set (value) {
               builderResult.repeatedNestedMessage = value
           }
      }
      public func setRepeatedNestedMessage(value:Array<Proto3ArenaUnittest.TestAllTypes.NestedMessage>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedNestedMessage = value
        return self
      }
      public func clearRepeatedNestedMessage() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        builderResult.repeatedNestedMessage.removeAll(keepCapacity: false)
        return self
      }
      public var repeatedForeignMessage:Array<Proto3ArenaUnittest.ForeignMessage> {
           get {
               return builderResult.repeatedForeignMessage
           }
           set (value) {
               builderResult.repeatedForeignMessage = value
           }
      }
      public func setRepeatedForeignMessage(value:Array<Proto3ArenaUnittest.ForeignMessage>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedForeignMessage = value
        return self
      }
      public func clearRepeatedForeignMessage() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        builderResult.repeatedForeignMessage.removeAll(keepCapacity: false)
        return self
      }
      public var repeatedImportMessage:Array<ProtobufUnittestImport.ImportMessage> {
           get {
               return builderResult.repeatedImportMessage
           }
           set (value) {
               builderResult.repeatedImportMessage = value
           }
      }
      public func setRepeatedImportMessage(value:Array<ProtobufUnittestImport.ImportMessage>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedImportMessage = value
        return self
      }
      public func clearRepeatedImportMessage() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        builderResult.repeatedImportMessage.removeAll(keepCapacity: false)
        return self
      }
      public var repeatedNestedEnum:Array<Proto3ArenaUnittest.TestAllTypes.NestedEnum> {
          get {
              return builderResult.repeatedNestedEnum
          }
          set (value) {
              builderResult.repeatedNestedEnum = value
          }
      }
      public func setRepeatedNestedEnum(value:Array<Proto3ArenaUnittest.TestAllTypes.NestedEnum>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedNestedEnum = value
        return self
      }
      public func clearRepeatedNestedEnum() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        builderResult.repeatedNestedEnum.removeAll(keepCapacity: false)
        return self
      }
      public var repeatedForeignEnum:Array<Proto3ArenaUnittest.ForeignEnum> {
          get {
              return builderResult.repeatedForeignEnum
          }
          set (value) {
              builderResult.repeatedForeignEnum = value
          }
      }
      public func setRepeatedForeignEnum(value:Array<Proto3ArenaUnittest.ForeignEnum>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedForeignEnum = value
        return self
      }
      public func clearRepeatedForeignEnum() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        builderResult.repeatedForeignEnum.removeAll(keepCapacity: false)
        return self
      }
      public var repeatedStringPiece:Array<String> {
           get {
               return builderResult.repeatedStringPiece
           }
           set (array) {
               builderResult.repeatedStringPiece = array
           }
      }
      public func setRepeatedStringPiece(value:Array<String>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedStringPiece = value
        return self
      }
      public func clearRepeatedStringPiece() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedStringPiece.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedCord:Array<String> {
           get {
               return builderResult.repeatedCord
           }
           set (array) {
               builderResult.repeatedCord = array
           }
      }
      public func setRepeatedCord(value:Array<String>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedCord = value
        return self
      }
      public func clearRepeatedCord() -> Proto3ArenaUnittest.TestAllTypes.Builder {
         builderResult.repeatedCord.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedLazyMessage:Array<Proto3ArenaUnittest.TestAllTypes.NestedMessage> {
           get {
               return builderResult.repeatedLazyMessage
           }
           set (value) {
               builderResult.repeatedLazyMessage = value
           }
      }
      public func setRepeatedLazyMessage(value:Array<Proto3ArenaUnittest.TestAllTypes.NestedMessage>) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.repeatedLazyMessage = value
        return self
      }
      public func clearRepeatedLazyMessage() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        builderResult.repeatedLazyMessage.removeAll(keepCapacity: false)
        return self
      }
      public var hasOneofUint32:Bool {
           get {
                return builderResult.hasOneofUint32
           }
      }
      public var oneofUint32:UInt32 {
           get {
                return builderResult.oneofUint32
           }
           set (value) {
               builderResult.hasOneofUint32 = true
               builderResult.oneofUint32 = value
           }
      }
      public func setOneofUint32(value:UInt32) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.oneofUint32 = value
        return self
      }
      public func clearOneofUint32() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOneofUint32 = false
           builderResult.oneofUint32 = UInt32(0)
           return self
      }
      public var hasOneofNestedMessage:Bool {
           get {
               return builderResult.hasOneofNestedMessage
           }
      }
      public var oneofNestedMessage:Proto3ArenaUnittest.TestAllTypes.NestedMessage! {
           get {
               if oneofNestedMessageBuilder_ != nil {
                  builderResult.oneofNestedMessage = oneofNestedMessageBuilder_.getMessage()
               }
               return builderResult.oneofNestedMessage
           }
           set (value) {
               builderResult.hasOneofNestedMessage = true
               builderResult.oneofNestedMessage = value
           }
      }
      private var oneofNestedMessageBuilder_:Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder! {
           didSet {
              builderResult.hasOneofNestedMessage = true
           }
      }
      public func getOneofNestedMessageBuilder() -> Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder {
        if oneofNestedMessageBuilder_ == nil {
           oneofNestedMessageBuilder_ = Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder()
           builderResult.oneofNestedMessage = oneofNestedMessageBuilder_.getMessage()
           if oneofNestedMessage != nil {
              try! oneofNestedMessageBuilder_.mergeFrom(oneofNestedMessage)
           }
        }
        return oneofNestedMessageBuilder_
      }
      public func setOneofNestedMessage(value:Proto3ArenaUnittest.TestAllTypes.NestedMessage!) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.oneofNestedMessage = value
        return self
      }
      public func mergeOneofNestedMessage(value:Proto3ArenaUnittest.TestAllTypes.NestedMessage) throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
        if builderResult.hasOneofNestedMessage {
          builderResult.oneofNestedMessage = try Proto3ArenaUnittest.TestAllTypes.NestedMessage.builderWithPrototype(builderResult.oneofNestedMessage).mergeFrom(value).buildPartial()
        } else {
          builderResult.oneofNestedMessage = value
        }
        builderResult.hasOneofNestedMessage = true
        return self
      }
      public func clearOneofNestedMessage() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        oneofNestedMessageBuilder_ = nil
        builderResult.hasOneofNestedMessage = false
        builderResult.oneofNestedMessage = nil
        return self
      }
      public var hasOneofString:Bool {
           get {
                return builderResult.hasOneofString
           }
      }
      public var oneofString:String {
           get {
                return builderResult.oneofString
           }
           set (value) {
               builderResult.hasOneofString = true
               builderResult.oneofString = value
           }
      }
      public func setOneofString(value:String) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.oneofString = value
        return self
      }
      public func clearOneofString() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOneofString = false
           builderResult.oneofString = ""
           return self
      }
      public var hasOneofBytes:Bool {
           get {
                return builderResult.hasOneofBytes
           }
      }
      public var oneofBytes:NSData {
           get {
                return builderResult.oneofBytes
           }
           set (value) {
               builderResult.hasOneofBytes = true
               builderResult.oneofBytes = value
           }
      }
      public func setOneofBytes(value:NSData) -> Proto3ArenaUnittest.TestAllTypes.Builder {
        self.oneofBytes = value
        return self
      }
      public func clearOneofBytes() -> Proto3ArenaUnittest.TestAllTypes.Builder{
           builderResult.hasOneofBytes = false
           builderResult.oneofBytes = NSData()
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        builderResult = Proto3ArenaUnittest.TestAllTypes()
        return self
      }
      override public func clone() throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
        return try Proto3ArenaUnittest.TestAllTypes.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Proto3ArenaUnittest.TestAllTypes {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Proto3ArenaUnittest.TestAllTypes {
        let returnMe:Proto3ArenaUnittest.TestAllTypes = builderResult
        return returnMe
      }
      public func mergeFrom(other:Proto3ArenaUnittest.TestAllTypes) throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
        if other == Proto3ArenaUnittest.TestAllTypes() {
         return self
        }
        if other.hasOptionalInt32 {
             optionalInt32 = other.optionalInt32
        }
        if other.hasOptionalInt64 {
             optionalInt64 = other.optionalInt64
        }
        if other.hasOptionalUint32 {
             optionalUint32 = other.optionalUint32
        }
        if other.hasOptionalUint64 {
             optionalUint64 = other.optionalUint64
        }
        if other.hasOptionalSint32 {
             optionalSint32 = other.optionalSint32
        }
        if other.hasOptionalSint64 {
             optionalSint64 = other.optionalSint64
        }
        if other.hasOptionalFixed32 {
             optionalFixed32 = other.optionalFixed32
        }
        if other.hasOptionalFixed64 {
             optionalFixed64 = other.optionalFixed64
        }
        if other.hasOptionalSfixed32 {
             optionalSfixed32 = other.optionalSfixed32
        }
        if other.hasOptionalSfixed64 {
             optionalSfixed64 = other.optionalSfixed64
        }
        if other.hasOptionalFloat {
             optionalFloat = other.optionalFloat
        }
        if other.hasOptionalDouble {
             optionalDouble = other.optionalDouble
        }
        if other.hasOptionalBool {
             optionalBool = other.optionalBool
        }
        if other.hasOptionalString {
             optionalString = other.optionalString
        }
        if other.hasOptionalBytes {
             optionalBytes = other.optionalBytes
        }
        if (other.hasOptionalNestedMessage) {
            try mergeOptionalNestedMessage(other.optionalNestedMessage)
        }
        if (other.hasOptionalForeignMessage) {
            try mergeOptionalForeignMessage(other.optionalForeignMessage)
        }
        if (other.hasOptionalImportMessage) {
            try mergeOptionalImportMessage(other.optionalImportMessage)
        }
        if other.hasOptionalNestedEnum {
             optionalNestedEnum = other.optionalNestedEnum
        }
        if other.hasOptionalForeignEnum {
             optionalForeignEnum = other.optionalForeignEnum
        }
        if other.hasOptionalStringPiece {
             optionalStringPiece = other.optionalStringPiece
        }
        if other.hasOptionalCord {
             optionalCord = other.optionalCord
        }
        if (other.hasOptionalPublicImportMessage) {
            try mergeOptionalPublicImportMessage(other.optionalPublicImportMessage)
        }
        if (other.hasOptionalLazyMessage) {
            try mergeOptionalLazyMessage(other.optionalLazyMessage)
        }
        if !other.repeatedInt32.isEmpty {
            builderResult.repeatedInt32 += other.repeatedInt32
        }
        if !other.repeatedInt64.isEmpty {
            builderResult.repeatedInt64 += other.repeatedInt64
        }
        if !other.repeatedUint32.isEmpty {
            builderResult.repeatedUint32 += other.repeatedUint32
        }
        if !other.repeatedUint64.isEmpty {
            builderResult.repeatedUint64 += other.repeatedUint64
        }
        if !other.repeatedSint32.isEmpty {
            builderResult.repeatedSint32 += other.repeatedSint32
        }
        if !other.repeatedSint64.isEmpty {
            builderResult.repeatedSint64 += other.repeatedSint64
        }
        if !other.repeatedFixed32.isEmpty {
            builderResult.repeatedFixed32 += other.repeatedFixed32
        }
        if !other.repeatedFixed64.isEmpty {
            builderResult.repeatedFixed64 += other.repeatedFixed64
        }
        if !other.repeatedSfixed32.isEmpty {
            builderResult.repeatedSfixed32 += other.repeatedSfixed32
        }
        if !other.repeatedSfixed64.isEmpty {
            builderResult.repeatedSfixed64 += other.repeatedSfixed64
        }
        if !other.repeatedFloat.isEmpty {
            builderResult.repeatedFloat += other.repeatedFloat
        }
        if !other.repeatedDouble.isEmpty {
            builderResult.repeatedDouble += other.repeatedDouble
        }
        if !other.repeatedBool.isEmpty {
            builderResult.repeatedBool += other.repeatedBool
        }
        if !other.repeatedString.isEmpty {
            builderResult.repeatedString += other.repeatedString
        }
        if !other.repeatedBytes.isEmpty {
            builderResult.repeatedBytes += other.repeatedBytes
        }
        if !other.repeatedNestedMessage.isEmpty  {
           builderResult.repeatedNestedMessage += other.repeatedNestedMessage
        }
        if !other.repeatedForeignMessage.isEmpty  {
           builderResult.repeatedForeignMessage += other.repeatedForeignMessage
        }
        if !other.repeatedImportMessage.isEmpty  {
           builderResult.repeatedImportMessage += other.repeatedImportMessage
        }
        if !other.repeatedNestedEnum.isEmpty {
           builderResult.repeatedNestedEnum += other.repeatedNestedEnum
        }
        if !other.repeatedForeignEnum.isEmpty {
           builderResult.repeatedForeignEnum += other.repeatedForeignEnum
        }
        if !other.repeatedStringPiece.isEmpty {
            builderResult.repeatedStringPiece += other.repeatedStringPiece
        }
        if !other.repeatedCord.isEmpty {
            builderResult.repeatedCord += other.repeatedCord
        }
        if !other.repeatedLazyMessage.isEmpty  {
           builderResult.repeatedLazyMessage += other.repeatedLazyMessage
        }
        if other.hasOneofUint32 {
             oneofUint32 = other.oneofUint32
        }
        if (other.hasOneofNestedMessage) {
            try mergeOneofNestedMessage(other.oneofNestedMessage)
        }
        if other.hasOneofString {
             oneofString = other.oneofString
        }
        if other.hasOneofBytes {
             oneofBytes = other.oneofBytes
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            optionalInt32 = try input.readInt32()

          case 16 :
            optionalInt64 = try input.readInt64()

          case 24 :
            optionalUint32 = try input.readUInt32()

          case 32 :
            optionalUint64 = try input.readUInt64()

          case 40 :
            optionalSint32 = try input.readSInt32()

          case 48 :
            optionalSint64 = try input.readSInt64()

          case 61 :
            optionalFixed32 = try input.readFixed32()

          case 65 :
            optionalFixed64 = try input.readFixed64()

          case 77 :
            optionalSfixed32 = try input.readSFixed32()

          case 81 :
            optionalSfixed64 = try input.readSFixed64()

          case 93 :
            optionalFloat = try input.readFloat()

          case 97 :
            optionalDouble = try input.readDouble()

          case 104 :
            optionalBool = try input.readBool()

          case 114 :
            optionalString = try input.readString()

          case 122 :
            optionalBytes = try input.readData()

          case 146 :
            let subBuilder:Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder = Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder()
            if hasOptionalNestedMessage {
              try subBuilder.mergeFrom(optionalNestedMessage)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            optionalNestedMessage = subBuilder.buildPartial()

          case 154 :
            let subBuilder:Proto3ArenaUnittest.ForeignMessage.Builder = Proto3ArenaUnittest.ForeignMessage.Builder()
            if hasOptionalForeignMessage {
              try subBuilder.mergeFrom(optionalForeignMessage)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            optionalForeignMessage = subBuilder.buildPartial()

          case 162 :
            let subBuilder:ProtobufUnittestImport.ImportMessage.Builder = ProtobufUnittestImport.ImportMessage.Builder()
            if hasOptionalImportMessage {
              try subBuilder.mergeFrom(optionalImportMessage)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            optionalImportMessage = subBuilder.buildPartial()

          case 168 :
            let valueIntoptionalNestedEnum = try input.readEnum()
            if let enumsoptionalNestedEnum = Proto3ArenaUnittest.TestAllTypes.NestedEnum(rawValue:valueIntoptionalNestedEnum){
                 optionalNestedEnum = enumsoptionalNestedEnum
            } else {
                 try unknownFieldsBuilder.mergeVarintField(21, value:Int64(valueIntoptionalNestedEnum))
            }

          case 176 :
            let valueIntoptionalForeignEnum = try input.readEnum()
            if let enumsoptionalForeignEnum = Proto3ArenaUnittest.ForeignEnum(rawValue:valueIntoptionalForeignEnum){
                 optionalForeignEnum = enumsoptionalForeignEnum
            } else {
                 try unknownFieldsBuilder.mergeVarintField(22, value:Int64(valueIntoptionalForeignEnum))
            }

          case 194 :
            optionalStringPiece = try input.readString()

          case 202 :
            optionalCord = try input.readString()

          case 210 :
            let subBuilder:ProtobufUnittestImport.PublicImportMessage.Builder = ProtobufUnittestImport.PublicImportMessage.Builder()
            if hasOptionalPublicImportMessage {
              try subBuilder.mergeFrom(optionalPublicImportMessage)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            optionalPublicImportMessage = subBuilder.buildPartial()

          case 218 :
            let subBuilder:Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder = Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder()
            if hasOptionalLazyMessage {
              try subBuilder.mergeFrom(optionalLazyMessage)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            optionalLazyMessage = subBuilder.buildPartial()

          case 250 :
            repeatedInt32 += [try input.readInt32()]

          case 258 :
            repeatedInt64 += [try input.readInt64()]

          case 266 :
            repeatedUint32 += [try input.readUInt32()]

          case 274 :
            repeatedUint64 += [try input.readUInt64()]

          case 282 :
            repeatedSint32 += [try input.readSInt32()]

          case 290 :
            repeatedSint64 += [try input.readSInt64()]

          case 298 :
            repeatedFixed32 += [try input.readFixed32()]

          case 306 :
            repeatedFixed64 += [try input.readFixed64()]

          case 314 :
            repeatedSfixed32 += [try input.readSFixed32()]

          case 322 :
            repeatedSfixed64 += [try input.readSFixed64()]

          case 330 :
            repeatedFloat += [try input.readFloat()]

          case 338 :
            repeatedDouble += [try input.readDouble()]

          case 346 :
            repeatedBool += [try input.readBool()]

          case 354 :
            repeatedString += [try input.readString()]

          case 362 :
            repeatedBytes += [try input.readData()]

          case 386 :
            let subBuilder = Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            repeatedNestedMessage += [subBuilder.buildPartial()]

          case 394 :
            let subBuilder = Proto3ArenaUnittest.ForeignMessage.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            repeatedForeignMessage += [subBuilder.buildPartial()]

          case 402 :
            let subBuilder = ProtobufUnittestImport.ImportMessage.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            repeatedImportMessage += [subBuilder.buildPartial()]

          case 410 :
            let valueIntrepeatedNestedEnum = try input.readEnum()
            if let enumsrepeatedNestedEnum = Proto3ArenaUnittest.TestAllTypes.NestedEnum(rawValue:valueIntrepeatedNestedEnum) {
                 builderResult.repeatedNestedEnum += [enumsrepeatedNestedEnum]
            } else {
                 try unknownFieldsBuilder.mergeVarintField(51, value:Int64(valueIntrepeatedNestedEnum))
            }

          case 418 :
            let valueIntrepeatedForeignEnum = try input.readEnum()
            if let enumsrepeatedForeignEnum = Proto3ArenaUnittest.ForeignEnum(rawValue:valueIntrepeatedForeignEnum) {
                 builderResult.repeatedForeignEnum += [enumsrepeatedForeignEnum]
            } else {
                 try unknownFieldsBuilder.mergeVarintField(52, value:Int64(valueIntrepeatedForeignEnum))
            }

          case 434 :
            repeatedStringPiece += [try input.readString()]

          case 442 :
            repeatedCord += [try input.readString()]

          case 458 :
            let subBuilder = Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            repeatedLazyMessage += [subBuilder.buildPartial()]

          case 888 :
            oneofUint32 = try input.readUInt32()

          case 898 :
            let subBuilder:Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder = Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder()
            if hasOneofNestedMessage {
              try subBuilder.mergeFrom(oneofNestedMessage)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            oneofNestedMessage = subBuilder.buildPartial()

          case 906 :
            oneofString = try input.readString()

          case 914 :
            oneofBytes = try input.readData()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
        let resultDecodedBuilder = Proto3ArenaUnittest.TestAllTypes.Builder()
        if let jsonValueOptionalInt32 = jsonMap["optionalInt32"] as? NSNumber {
          resultDecodedBuilder.optionalInt32 = jsonValueOptionalInt32.intValue
        }
        if let jsonValueOptionalInt64 = jsonMap["optionalInt64"] as? String {
          resultDecodedBuilder.optionalInt64 = Int64(jsonValueOptionalInt64)!
        }
        if let jsonValueOptionalUint32 = jsonMap["optionalUint32"] as? NSNumber {
          resultDecodedBuilder.optionalUint32 = jsonValueOptionalUint32.unsignedIntValue
        }
        if let jsonValueOptionalUint64 = jsonMap["optionalUint64"] as? String {
          resultDecodedBuilder.optionalUint64 = UInt64(jsonValueOptionalUint64)!
        }
        if let jsonValueOptionalSint32 = jsonMap["optionalSint32"] as? NSNumber {
          resultDecodedBuilder.optionalSint32 = jsonValueOptionalSint32.intValue
        }
        if let jsonValueOptionalSint64 = jsonMap["optionalSint64"] as? String {
          resultDecodedBuilder.optionalSint64 = Int64(jsonValueOptionalSint64)!
        }
        if let jsonValueOptionalFixed32 = jsonMap["optionalFixed32"] as? NSNumber {
          resultDecodedBuilder.optionalFixed32 = jsonValueOptionalFixed32.unsignedIntValue
        }
        if let jsonValueOptionalFixed64 = jsonMap["optionalFixed64"] as? String {
          resultDecodedBuilder.optionalFixed64 = UInt64(jsonValueOptionalFixed64)!
        }
        if let jsonValueOptionalSfixed32 = jsonMap["optionalSfixed32"] as? NSNumber {
          resultDecodedBuilder.optionalSfixed32 = jsonValueOptionalSfixed32.intValue
        }
        if let jsonValueOptionalSfixed64 = jsonMap["optionalSfixed64"] as? String {
          resultDecodedBuilder.optionalSfixed64 = Int64(jsonValueOptionalSfixed64)!
        }
        if let jsonValueOptionalFloat = jsonMap["optionalFloat"] as? NSNumber {
          resultDecodedBuilder.optionalFloat = jsonValueOptionalFloat.floatValue
        }
        if let jsonValueOptionalDouble = jsonMap["optionalDouble"] as? NSNumber {
          resultDecodedBuilder.optionalDouble = jsonValueOptionalDouble.doubleValue
        }
        if let jsonValueOptionalBool = jsonMap["optionalBool"] as? Bool {
          resultDecodedBuilder.optionalBool = jsonValueOptionalBool
        }
        if let jsonValueOptionalString = jsonMap["optionalString"] as? String {
          resultDecodedBuilder.optionalString = jsonValueOptionalString
        }
        if let jsonValueOptionalBytes = jsonMap["optionalBytes"] as? String {
          resultDecodedBuilder.optionalBytes = NSData(base64EncodedString:jsonValueOptionalBytes, options: NSDataBase64DecodingOptions(rawValue:0))!
        }
        if let jsonValueOptionalNestedMessage = jsonMap["optionalNestedMessage"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.optionalNestedMessage = try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonValueOptionalNestedMessage).build()

        }
        if let jsonValueOptionalForeignMessage = jsonMap["optionalForeignMessage"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.optionalForeignMessage = try Proto3ArenaUnittest.ForeignMessage.Builder.decodeToBuilder(jsonValueOptionalForeignMessage).build()

        }
        if let jsonValueOptionalImportMessage = jsonMap["optionalImportMessage"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.optionalImportMessage = try ProtobufUnittestImport.ImportMessage.Builder.decodeToBuilder(jsonValueOptionalImportMessage).build()

        }
        if let jsonValueOptionalNestedEnum = jsonMap["optionalNestedEnum"] as? String {
          resultDecodedBuilder.optionalNestedEnum = try Proto3ArenaUnittest.TestAllTypes.NestedEnum.fromString(jsonValueOptionalNestedEnum)
        }
        if let jsonValueOptionalForeignEnum = jsonMap["optionalForeignEnum"] as? String {
          resultDecodedBuilder.optionalForeignEnum = try Proto3ArenaUnittest.ForeignEnum.fromString(jsonValueOptionalForeignEnum)
        }
        if let jsonValueOptionalStringPiece = jsonMap["optionalStringPiece"] as? String {
          resultDecodedBuilder.optionalStringPiece = jsonValueOptionalStringPiece
        }
        if let jsonValueOptionalCord = jsonMap["optionalCord"] as? String {
          resultDecodedBuilder.optionalCord = jsonValueOptionalCord
        }
        if let jsonValueOptionalPublicImportMessage = jsonMap["optionalPublicImportMessage"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.optionalPublicImportMessage = try ProtobufUnittestImport.PublicImportMessage.Builder.decodeToBuilder(jsonValueOptionalPublicImportMessage).build()

        }
        if let jsonValueOptionalLazyMessage = jsonMap["optionalLazyMessage"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.optionalLazyMessage = try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonValueOptionalLazyMessage).build()

        }
        if let jsonValueRepeatedInt32 = jsonMap["repeatedInt32"] as? Array<NSNumber> {
          var jsonArrayRepeatedInt32:Array<Int32> = []
          for oneValueRepeatedInt32 in jsonValueRepeatedInt32 {
            jsonArrayRepeatedInt32 += [oneValueRepeatedInt32.intValue]
          }
          resultDecodedBuilder.repeatedInt32 = jsonArrayRepeatedInt32
        }
        if let jsonValueRepeatedInt64 = jsonMap["repeatedInt64"] as? Array<String> {
          var jsonArrayRepeatedInt64:Array<Int64> = []
          for oneValueRepeatedInt64 in jsonValueRepeatedInt64 {
            jsonArrayRepeatedInt64 += [Int64(oneValueRepeatedInt64)!]
          }
          resultDecodedBuilder.repeatedInt64 = jsonArrayRepeatedInt64
        }
        if let jsonValueRepeatedUint32 = jsonMap["repeatedUint32"] as? Array<NSNumber> {
          var jsonArrayRepeatedUint32:Array<UInt32> = []
          for oneValueRepeatedUint32 in jsonValueRepeatedUint32 {
            jsonArrayRepeatedUint32 += [oneValueRepeatedUint32.unsignedIntValue]
          }
          resultDecodedBuilder.repeatedUint32 = jsonArrayRepeatedUint32
        }
        if let jsonValueRepeatedUint64 = jsonMap["repeatedUint64"] as? Array<String> {
          var jsonArrayRepeatedUint64:Array<UInt64> = []
          for oneValueRepeatedUint64 in jsonValueRepeatedUint64 {
            jsonArrayRepeatedUint64 += [UInt64(oneValueRepeatedUint64)!]
          }
          resultDecodedBuilder.repeatedUint64 = jsonArrayRepeatedUint64
        }
        if let jsonValueRepeatedSint32 = jsonMap["repeatedSint32"] as? Array<NSNumber> {
          var jsonArrayRepeatedSint32:Array<Int32> = []
          for oneValueRepeatedSint32 in jsonValueRepeatedSint32 {
            jsonArrayRepeatedSint32 += [oneValueRepeatedSint32.intValue]
          }
          resultDecodedBuilder.repeatedSint32 = jsonArrayRepeatedSint32
        }
        if let jsonValueRepeatedSint64 = jsonMap["repeatedSint64"] as? Array<String> {
          var jsonArrayRepeatedSint64:Array<Int64> = []
          for oneValueRepeatedSint64 in jsonValueRepeatedSint64 {
            jsonArrayRepeatedSint64 += [Int64(oneValueRepeatedSint64)!]
          }
          resultDecodedBuilder.repeatedSint64 = jsonArrayRepeatedSint64
        }
        if let jsonValueRepeatedFixed32 = jsonMap["repeatedFixed32"] as? Array<NSNumber> {
          var jsonArrayRepeatedFixed32:Array<UInt32> = []
          for oneValueRepeatedFixed32 in jsonValueRepeatedFixed32 {
            jsonArrayRepeatedFixed32 += [oneValueRepeatedFixed32.unsignedIntValue]
          }
          resultDecodedBuilder.repeatedFixed32 = jsonArrayRepeatedFixed32
        }
        if let jsonValueRepeatedFixed64 = jsonMap["repeatedFixed64"] as? Array<String> {
          var jsonArrayRepeatedFixed64:Array<UInt64> = []
          for oneValueRepeatedFixed64 in jsonValueRepeatedFixed64 {
            jsonArrayRepeatedFixed64 += [UInt64(oneValueRepeatedFixed64)!]
          }
          resultDecodedBuilder.repeatedFixed64 = jsonArrayRepeatedFixed64
        }
        if let jsonValueRepeatedSfixed32 = jsonMap["repeatedSfixed32"] as? Array<NSNumber> {
          var jsonArrayRepeatedSfixed32:Array<Int32> = []
          for oneValueRepeatedSfixed32 in jsonValueRepeatedSfixed32 {
            jsonArrayRepeatedSfixed32 += [oneValueRepeatedSfixed32.intValue]
          }
          resultDecodedBuilder.repeatedSfixed32 = jsonArrayRepeatedSfixed32
        }
        if let jsonValueRepeatedSfixed64 = jsonMap["repeatedSfixed64"] as? Array<String> {
          var jsonArrayRepeatedSfixed64:Array<Int64> = []
          for oneValueRepeatedSfixed64 in jsonValueRepeatedSfixed64 {
            jsonArrayRepeatedSfixed64 += [Int64(oneValueRepeatedSfixed64)!]
          }
          resultDecodedBuilder.repeatedSfixed64 = jsonArrayRepeatedSfixed64
        }
        if let jsonValueRepeatedFloat = jsonMap["repeatedFloat"] as? Array<NSNumber> {
          var jsonArrayRepeatedFloat:Array<Float> = []
          for oneValueRepeatedFloat in jsonValueRepeatedFloat {
            jsonArrayRepeatedFloat += [oneValueRepeatedFloat.floatValue]
          }
          resultDecodedBuilder.repeatedFloat = jsonArrayRepeatedFloat
        }
        if let jsonValueRepeatedDouble = jsonMap["repeatedDouble"] as? Array<NSNumber> {
          var jsonArrayRepeatedDouble:Array<Double> = []
          for oneValueRepeatedDouble in jsonValueRepeatedDouble {
            jsonArrayRepeatedDouble += [oneValueRepeatedDouble.doubleValue]
          }
          resultDecodedBuilder.repeatedDouble = jsonArrayRepeatedDouble
        }
        if let jsonValueRepeatedBool = jsonMap["repeatedBool"] as? Array<Bool> {
          resultDecodedBuilder.repeatedBool = jsonValueRepeatedBool
        }
        if let jsonValueRepeatedString = jsonMap["repeatedString"] as? Array<String> {
          resultDecodedBuilder.repeatedString = jsonValueRepeatedString
        }
        if let jsonValueRepeatedBytes = jsonMap["repeatedBytes"] as? Array<String> {
          var jsonArrayRepeatedBytes:Array<NSData> = []
          for oneValueRepeatedBytes in jsonValueRepeatedBytes {
            jsonArrayRepeatedBytes += [NSData(base64EncodedString:oneValueRepeatedBytes, options: NSDataBase64DecodingOptions(rawValue:0))!]
          }
          resultDecodedBuilder.repeatedBytes = jsonArrayRepeatedBytes
        }
        if let jsonValueRepeatedNestedMessage = jsonMap["repeatedNestedMessage"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayRepeatedNestedMessage:Array<Proto3ArenaUnittest.TestAllTypes.NestedMessage> = []
          for oneValueRepeatedNestedMessage in jsonValueRepeatedNestedMessage {
            let messageFromStringRepeatedNestedMessage = try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder.decodeToBuilder(oneValueRepeatedNestedMessage).build()

            jsonArrayRepeatedNestedMessage += [messageFromStringRepeatedNestedMessage]
          }
          resultDecodedBuilder.repeatedNestedMessage = jsonArrayRepeatedNestedMessage
        }
        if let jsonValueRepeatedForeignMessage = jsonMap["repeatedForeignMessage"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayRepeatedForeignMessage:Array<Proto3ArenaUnittest.ForeignMessage> = []
          for oneValueRepeatedForeignMessage in jsonValueRepeatedForeignMessage {
            let messageFromStringRepeatedForeignMessage = try Proto3ArenaUnittest.ForeignMessage.Builder.decodeToBuilder(oneValueRepeatedForeignMessage).build()

            jsonArrayRepeatedForeignMessage += [messageFromStringRepeatedForeignMessage]
          }
          resultDecodedBuilder.repeatedForeignMessage = jsonArrayRepeatedForeignMessage
        }
        if let jsonValueRepeatedImportMessage = jsonMap["repeatedImportMessage"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayRepeatedImportMessage:Array<ProtobufUnittestImport.ImportMessage> = []
          for oneValueRepeatedImportMessage in jsonValueRepeatedImportMessage {
            let messageFromStringRepeatedImportMessage = try ProtobufUnittestImport.ImportMessage.Builder.decodeToBuilder(oneValueRepeatedImportMessage).build()

            jsonArrayRepeatedImportMessage += [messageFromStringRepeatedImportMessage]
          }
          resultDecodedBuilder.repeatedImportMessage = jsonArrayRepeatedImportMessage
        }
        if let jsonValueRepeatedNestedEnum = jsonMap["repeatedNestedEnum"] as? Array<String> {
          var jsonArrayRepeatedNestedEnum:Array<Proto3ArenaUnittest.TestAllTypes.NestedEnum> = []
          for oneValueRepeatedNestedEnum in jsonValueRepeatedNestedEnum {
            let enumFromStringRepeatedNestedEnum = try Proto3ArenaUnittest.TestAllTypes.NestedEnum.fromString(oneValueRepeatedNestedEnum)
            jsonArrayRepeatedNestedEnum += [enumFromStringRepeatedNestedEnum]
          }
          resultDecodedBuilder.repeatedNestedEnum = jsonArrayRepeatedNestedEnum
        }
        if let jsonValueRepeatedForeignEnum = jsonMap["repeatedForeignEnum"] as? Array<String> {
          var jsonArrayRepeatedForeignEnum:Array<Proto3ArenaUnittest.ForeignEnum> = []
          for oneValueRepeatedForeignEnum in jsonValueRepeatedForeignEnum {
            let enumFromStringRepeatedForeignEnum = try Proto3ArenaUnittest.ForeignEnum.fromString(oneValueRepeatedForeignEnum)
            jsonArrayRepeatedForeignEnum += [enumFromStringRepeatedForeignEnum]
          }
          resultDecodedBuilder.repeatedForeignEnum = jsonArrayRepeatedForeignEnum
        }
        if let jsonValueRepeatedStringPiece = jsonMap["repeatedStringPiece"] as? Array<String> {
          resultDecodedBuilder.repeatedStringPiece = jsonValueRepeatedStringPiece
        }
        if let jsonValueRepeatedCord = jsonMap["repeatedCord"] as? Array<String> {
          resultDecodedBuilder.repeatedCord = jsonValueRepeatedCord
        }
        if let jsonValueRepeatedLazyMessage = jsonMap["repeatedLazyMessage"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayRepeatedLazyMessage:Array<Proto3ArenaUnittest.TestAllTypes.NestedMessage> = []
          for oneValueRepeatedLazyMessage in jsonValueRepeatedLazyMessage {
            let messageFromStringRepeatedLazyMessage = try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder.decodeToBuilder(oneValueRepeatedLazyMessage).build()

            jsonArrayRepeatedLazyMessage += [messageFromStringRepeatedLazyMessage]
          }
          resultDecodedBuilder.repeatedLazyMessage = jsonArrayRepeatedLazyMessage
        }
        if let jsonValueOneofUint32 = jsonMap["oneofUint32"] as? NSNumber {
          resultDecodedBuilder.oneofUint32 = jsonValueOneofUint32.unsignedIntValue
        }
        if let jsonValueOneofNestedMessage = jsonMap["oneofNestedMessage"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.oneofNestedMessage = try Proto3ArenaUnittest.TestAllTypes.NestedMessage.Builder.decodeToBuilder(jsonValueOneofNestedMessage).build()

        }
        if let jsonValueOneofString = jsonMap["oneofString"] as? String {
          resultDecodedBuilder.oneofString = jsonValueOneofString
        }
        if let jsonValueOneofBytes = jsonMap["oneofBytes"] as? String {
          resultDecodedBuilder.oneofBytes = NSData(base64EncodedString:jsonValueOneofBytes, options: NSDataBase64DecodingOptions(rawValue:0))!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Proto3ArenaUnittest.TestAllTypes.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Proto3ArenaUnittest.TestAllTypes.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class TestPackedTypes : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var packedInt32:Array<Int32> = Array<Int32>()
    private var packedInt32MemoizedSerializedSize:Int32 = -1
    public private(set) var packedInt64:Array<Int64> = Array<Int64>()
    private var packedInt64MemoizedSerializedSize:Int32 = -1
    public private(set) var packedUint32:Array<UInt32> = Array<UInt32>()
    private var packedUint32MemoizedSerializedSize:Int32 = -1
    public private(set) var packedUint64:Array<UInt64> = Array<UInt64>()
    private var packedUint64MemoizedSerializedSize:Int32 = -1
    public private(set) var packedSint32:Array<Int32> = Array<Int32>()
    private var packedSint32MemoizedSerializedSize:Int32 = -1
    public private(set) var packedSint64:Array<Int64> = Array<Int64>()
    private var packedSint64MemoizedSerializedSize:Int32 = -1
    public private(set) var packedFixed32:Array<UInt32> = Array<UInt32>()
    private var packedFixed32MemoizedSerializedSize:Int32 = -1
    public private(set) var packedFixed64:Array<UInt64> = Array<UInt64>()
    private var packedFixed64MemoizedSerializedSize:Int32 = -1
    public private(set) var packedSfixed32:Array<Int32> = Array<Int32>()
    private var packedSfixed32MemoizedSerializedSize:Int32 = -1
    public private(set) var packedSfixed64:Array<Int64> = Array<Int64>()
    private var packedSfixed64MemoizedSerializedSize:Int32 = -1
    public private(set) var packedFloat:Array<Float> = Array<Float>()
    private var packedFloatMemoizedSerializedSize:Int32 = -1
    public private(set) var packedDouble:Array<Double> = Array<Double>()
    private var packedDoubleMemoizedSerializedSize:Int32 = -1
    public private(set) var packedBool:Array<Bool> = Array<Bool>()
    private var packedBoolMemoizedSerializedSize:Int32 = -1
    private var packedEnumMemoizedSerializedSize:Int32 = 0
    public private(set) var packedEnum:Array<Proto3ArenaUnittest.ForeignEnum> = Array<Proto3ArenaUnittest.ForeignEnum>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if !packedInt32.isEmpty {
        try output.writeRawVarint32(722)
        try output.writeRawVarint32(packedInt32MemoizedSerializedSize)
        for oneValuepackedInt32 in packedInt32 {
          try output.writeInt32NoTag(oneValuepackedInt32)
        }
      }
      if !packedInt64.isEmpty {
        try output.writeRawVarint32(730)
        try output.writeRawVarint32(packedInt64MemoizedSerializedSize)
        for oneValuepackedInt64 in packedInt64 {
          try output.writeInt64NoTag(oneValuepackedInt64)
        }
      }
      if !packedUint32.isEmpty {
        try output.writeRawVarint32(738)
        try output.writeRawVarint32(packedUint32MemoizedSerializedSize)
        for oneValuepackedUint32 in packedUint32 {
          try output.writeUInt32NoTag(oneValuepackedUint32)
        }
      }
      if !packedUint64.isEmpty {
        try output.writeRawVarint32(746)
        try output.writeRawVarint32(packedUint64MemoizedSerializedSize)
        for oneValuepackedUint64 in packedUint64 {
          try output.writeUInt64NoTag(oneValuepackedUint64)
        }
      }
      if !packedSint32.isEmpty {
        try output.writeRawVarint32(754)
        try output.writeRawVarint32(packedSint32MemoizedSerializedSize)
        for oneValuepackedSint32 in packedSint32 {
          try output.writeSInt32NoTag(oneValuepackedSint32)
        }
      }
      if !packedSint64.isEmpty {
        try output.writeRawVarint32(762)
        try output.writeRawVarint32(packedSint64MemoizedSerializedSize)
        for oneValuepackedSint64 in packedSint64 {
          try output.writeSInt64NoTag(oneValuepackedSint64)
        }
      }
      if !packedFixed32.isEmpty {
        try output.writeRawVarint32(770)
        try output.writeRawVarint32(packedFixed32MemoizedSerializedSize)
        for oneValuepackedFixed32 in packedFixed32 {
          try output.writeFixed32NoTag(oneValuepackedFixed32)
        }
      }
      if !packedFixed64.isEmpty {
        try output.writeRawVarint32(778)
        try output.writeRawVarint32(packedFixed64MemoizedSerializedSize)
        for oneValuepackedFixed64 in packedFixed64 {
          try output.writeFixed64NoTag(oneValuepackedFixed64)
        }
      }
      if !packedSfixed32.isEmpty {
        try output.writeRawVarint32(786)
        try output.writeRawVarint32(packedSfixed32MemoizedSerializedSize)
        for oneValuepackedSfixed32 in packedSfixed32 {
          try output.writeSFixed32NoTag(oneValuepackedSfixed32)
        }
      }
      if !packedSfixed64.isEmpty {
        try output.writeRawVarint32(794)
        try output.writeRawVarint32(packedSfixed64MemoizedSerializedSize)
        for oneValuepackedSfixed64 in packedSfixed64 {
          try output.writeSFixed64NoTag(oneValuepackedSfixed64)
        }
      }
      if !packedFloat.isEmpty {
        try output.writeRawVarint32(802)
        try output.writeRawVarint32(packedFloatMemoizedSerializedSize)
        for oneValuepackedFloat in packedFloat {
          try output.writeFloatNoTag(oneValuepackedFloat)
        }
      }
      if !packedDouble.isEmpty {
        try output.writeRawVarint32(810)
        try output.writeRawVarint32(packedDoubleMemoizedSerializedSize)
        for oneValuepackedDouble in packedDouble {
          try output.writeDoubleNoTag(oneValuepackedDouble)
        }
      }
      if !packedBool.isEmpty {
        try output.writeRawVarint32(818)
        try output.writeRawVarint32(packedBoolMemoizedSerializedSize)
        for oneValuepackedBool in packedBool {
          try output.writeBoolNoTag(oneValuepackedBool)
        }
      }
      if !packedEnum.isEmpty {
        try output.writeRawVarint32(826)
        try output.writeRawVarint32(packedEnumMemoizedSerializedSize)
      }
      for oneValueOfpackedEnum in packedEnum {
          try output.writeEnumNoTag(oneValueOfpackedEnum.rawValue)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      var dataSizePackedInt32:Int32 = 0
      for oneValuepackedInt32 in packedInt32 {
          dataSizePackedInt32 += oneValuepackedInt32.computeInt32SizeNoTag()
      }
      serialize_size += dataSizePackedInt32
      if !packedInt32.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedInt32.computeInt32SizeNoTag()
      }
      packedInt32MemoizedSerializedSize = dataSizePackedInt32
      var dataSizePackedInt64:Int32 = 0
      for oneValuepackedInt64 in packedInt64 {
          dataSizePackedInt64 += oneValuepackedInt64.computeInt64SizeNoTag()
      }
      serialize_size += dataSizePackedInt64
      if !packedInt64.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedInt64.computeInt32SizeNoTag()
      }
      packedInt64MemoizedSerializedSize = dataSizePackedInt64
      var dataSizePackedUint32:Int32 = 0
      for oneValuepackedUint32 in packedUint32 {
          dataSizePackedUint32 += oneValuepackedUint32.computeUInt32SizeNoTag()
      }
      serialize_size += dataSizePackedUint32
      if !packedUint32.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedUint32.computeInt32SizeNoTag()
      }
      packedUint32MemoizedSerializedSize = dataSizePackedUint32
      var dataSizePackedUint64:Int32 = 0
      for oneValuepackedUint64 in packedUint64 {
          dataSizePackedUint64 += oneValuepackedUint64.computeUInt64SizeNoTag()
      }
      serialize_size += dataSizePackedUint64
      if !packedUint64.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedUint64.computeInt32SizeNoTag()
      }
      packedUint64MemoizedSerializedSize = dataSizePackedUint64
      var dataSizePackedSint32:Int32 = 0
      for oneValuepackedSint32 in packedSint32 {
          dataSizePackedSint32 += oneValuepackedSint32.computeSInt32SizeNoTag()
      }
      serialize_size += dataSizePackedSint32
      if !packedSint32.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedSint32.computeInt32SizeNoTag()
      }
      packedSint32MemoizedSerializedSize = dataSizePackedSint32
      var dataSizePackedSint64:Int32 = 0
      for oneValuepackedSint64 in packedSint64 {
          dataSizePackedSint64 += oneValuepackedSint64.computeSInt64SizeNoTag()
      }
      serialize_size += dataSizePackedSint64
      if !packedSint64.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedSint64.computeInt32SizeNoTag()
      }
      packedSint64MemoizedSerializedSize = dataSizePackedSint64
      var dataSizePackedFixed32:Int32 = 0
      dataSizePackedFixed32 = 4 * Int32(packedFixed32.count)
      serialize_size += dataSizePackedFixed32
      if !packedFixed32.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedFixed32.computeInt32SizeNoTag()
      }
      packedFixed32MemoizedSerializedSize = dataSizePackedFixed32
      var dataSizePackedFixed64:Int32 = 0
      dataSizePackedFixed64 = 8 * Int32(packedFixed64.count)
      serialize_size += dataSizePackedFixed64
      if !packedFixed64.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedFixed64.computeInt32SizeNoTag()
      }
      packedFixed64MemoizedSerializedSize = dataSizePackedFixed64
      var dataSizePackedSfixed32:Int32 = 0
      dataSizePackedSfixed32 = 4 * Int32(packedSfixed32.count)
      serialize_size += dataSizePackedSfixed32
      if !packedSfixed32.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedSfixed32.computeInt32SizeNoTag()
      }
      packedSfixed32MemoizedSerializedSize = dataSizePackedSfixed32
      var dataSizePackedSfixed64:Int32 = 0
      dataSizePackedSfixed64 = 8 * Int32(packedSfixed64.count)
      serialize_size += dataSizePackedSfixed64
      if !packedSfixed64.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedSfixed64.computeInt32SizeNoTag()
      }
      packedSfixed64MemoizedSerializedSize = dataSizePackedSfixed64
      var dataSizePackedFloat:Int32 = 0
      dataSizePackedFloat = 4 * Int32(packedFloat.count)
      serialize_size += dataSizePackedFloat
      if !packedFloat.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedFloat.computeInt32SizeNoTag()
      }
      packedFloatMemoizedSerializedSize = dataSizePackedFloat
      var dataSizePackedDouble:Int32 = 0
      dataSizePackedDouble = 8 * Int32(packedDouble.count)
      serialize_size += dataSizePackedDouble
      if !packedDouble.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedDouble.computeInt32SizeNoTag()
      }
      packedDoubleMemoizedSerializedSize = dataSizePackedDouble
      var dataSizePackedBool:Int32 = 0
      dataSizePackedBool = 1 * Int32(packedBool.count)
      serialize_size += dataSizePackedBool
      if !packedBool.isEmpty {
        serialize_size += 2
        serialize_size += dataSizePackedBool.computeInt32SizeNoTag()
      }
      packedBoolMemoizedSerializedSize = dataSizePackedBool
      var dataSizepackedEnum:Int32 = 0
      for oneValueOfpackedEnum in packedEnum {
          dataSizepackedEnum += oneValueOfpackedEnum.rawValue.computeEnumSizeNoTag()
      }
      serialize_size += dataSizepackedEnum
      if !packedEnum.isEmpty {
        serialize_size += 2
        serialize_size += dataSizepackedEnum.computeRawVarint32Size()
      }
      packedEnumMemoizedSerializedSize = dataSizepackedEnum
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Proto3ArenaUnittest.TestPackedTypes> {
      var mergedArray = Array<Proto3ArenaUnittest.TestPackedTypes>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.TestPackedTypes? {
      return try Proto3ArenaUnittest.TestPackedTypes.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Proto3ArenaUnittest.TestPackedTypes {
      return try Proto3ArenaUnittest.TestPackedTypes.Builder().mergeFromData(data, extensionRegistry:Proto3ArenaUnittest.UnittestProto3ArenaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestPackedTypes {
      return try Proto3ArenaUnittest.TestPackedTypes.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.TestPackedTypes {
      return try Proto3ArenaUnittest.TestPackedTypes.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestPackedTypes {
      return try Proto3ArenaUnittest.TestPackedTypes.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.TestPackedTypes {
      return try Proto3ArenaUnittest.TestPackedTypes.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestPackedTypes {
      return try Proto3ArenaUnittest.TestPackedTypes.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
      return Proto3ArenaUnittest.TestPackedTypes.classBuilder() as! Proto3ArenaUnittest.TestPackedTypes.Builder
    }
    public func getBuilder() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
      return classBuilder() as! Proto3ArenaUnittest.TestPackedTypes.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Proto3ArenaUnittest.TestPackedTypes.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Proto3ArenaUnittest.TestPackedTypes.Builder()
    }
    public func toBuilder() throws -> Proto3ArenaUnittest.TestPackedTypes.Builder {
      return try Proto3ArenaUnittest.TestPackedTypes.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Proto3ArenaUnittest.TestPackedTypes) throws -> Proto3ArenaUnittest.TestPackedTypes.Builder {
      return try Proto3ArenaUnittest.TestPackedTypes.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if !packedInt32.isEmpty {
        var jsonArrayPackedInt32:Array<NSNumber> = []
          for oneValuePackedInt32 in packedInt32 {
            jsonArrayPackedInt32 += [NSNumber(int:oneValuePackedInt32)]
          }
        jsonMap["packedInt32"] = jsonArrayPackedInt32
      }
      if !packedInt64.isEmpty {
        var jsonArrayPackedInt64:Array<String> = []
          for oneValuePackedInt64 in packedInt64 {
            jsonArrayPackedInt64 += ["\(oneValuePackedInt64)"]
          }
        jsonMap["packedInt64"] = jsonArrayPackedInt64
      }
      if !packedUint32.isEmpty {
        var jsonArrayPackedUint32:Array<NSNumber> = []
          for oneValuePackedUint32 in packedUint32 {
            jsonArrayPackedUint32 += [NSNumber(unsignedInt:oneValuePackedUint32)]
          }
        jsonMap["packedUint32"] = jsonArrayPackedUint32
      }
      if !packedUint64.isEmpty {
        var jsonArrayPackedUint64:Array<String> = []
          for oneValuePackedUint64 in packedUint64 {
            jsonArrayPackedUint64 += ["\(oneValuePackedUint64)"]
          }
        jsonMap["packedUint64"] = jsonArrayPackedUint64
      }
      if !packedSint32.isEmpty {
        var jsonArrayPackedSint32:Array<NSNumber> = []
          for oneValuePackedSint32 in packedSint32 {
            jsonArrayPackedSint32 += [NSNumber(int:oneValuePackedSint32)]
          }
        jsonMap["packedSint32"] = jsonArrayPackedSint32
      }
      if !packedSint64.isEmpty {
        var jsonArrayPackedSint64:Array<String> = []
          for oneValuePackedSint64 in packedSint64 {
            jsonArrayPackedSint64 += ["\(oneValuePackedSint64)"]
          }
        jsonMap["packedSint64"] = jsonArrayPackedSint64
      }
      if !packedFixed32.isEmpty {
        var jsonArrayPackedFixed32:Array<NSNumber> = []
          for oneValuePackedFixed32 in packedFixed32 {
            jsonArrayPackedFixed32 += [NSNumber(unsignedInt:oneValuePackedFixed32)]
          }
        jsonMap["packedFixed32"] = jsonArrayPackedFixed32
      }
      if !packedFixed64.isEmpty {
        var jsonArrayPackedFixed64:Array<String> = []
          for oneValuePackedFixed64 in packedFixed64 {
            jsonArrayPackedFixed64 += ["\(oneValuePackedFixed64)"]
          }
        jsonMap["packedFixed64"] = jsonArrayPackedFixed64
      }
      if !packedSfixed32.isEmpty {
        var jsonArrayPackedSfixed32:Array<NSNumber> = []
          for oneValuePackedSfixed32 in packedSfixed32 {
            jsonArrayPackedSfixed32 += [NSNumber(int:oneValuePackedSfixed32)]
          }
        jsonMap["packedSfixed32"] = jsonArrayPackedSfixed32
      }
      if !packedSfixed64.isEmpty {
        var jsonArrayPackedSfixed64:Array<String> = []
          for oneValuePackedSfixed64 in packedSfixed64 {
            jsonArrayPackedSfixed64 += ["\(oneValuePackedSfixed64)"]
          }
        jsonMap["packedSfixed64"] = jsonArrayPackedSfixed64
      }
      if !packedFloat.isEmpty {
        var jsonArrayPackedFloat:Array<NSNumber> = []
          for oneValuePackedFloat in packedFloat {
            jsonArrayPackedFloat += [NSNumber(float:oneValuePackedFloat)]
          }
        jsonMap["packedFloat"] = jsonArrayPackedFloat
      }
      if !packedDouble.isEmpty {
        var jsonArrayPackedDouble:Array<NSNumber> = []
          for oneValuePackedDouble in packedDouble {
            jsonArrayPackedDouble += [NSNumber(double:oneValuePackedDouble)]
          }
        jsonMap["packedDouble"] = jsonArrayPackedDouble
      }
      if !packedBool.isEmpty {
        jsonMap["packedBool"] = packedBool
      }
      if !packedEnum.isEmpty {
        var jsonArrayPackedEnum:Array<String> = []
          for oneValuePackedEnum in packedEnum {
            jsonArrayPackedEnum += [oneValuePackedEnum.toString()]
          }
        jsonMap["packedEnum"] = jsonArrayPackedEnum
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.TestPackedTypes {
      return try Proto3ArenaUnittest.TestPackedTypes.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Proto3ArenaUnittest.TestPackedTypes {
      return try Proto3ArenaUnittest.TestPackedTypes.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var packedInt32ElementIndex:Int = 0
      for oneValuePackedInt32 in packedInt32  {
          output += "\(indent) packedInt32[\(packedInt32ElementIndex)]: \(oneValuePackedInt32)\n"
          packedInt32ElementIndex++
      }
      var packedInt64ElementIndex:Int = 0
      for oneValuePackedInt64 in packedInt64  {
          output += "\(indent) packedInt64[\(packedInt64ElementIndex)]: \(oneValuePackedInt64)\n"
          packedInt64ElementIndex++
      }
      var packedUint32ElementIndex:Int = 0
      for oneValuePackedUint32 in packedUint32  {
          output += "\(indent) packedUint32[\(packedUint32ElementIndex)]: \(oneValuePackedUint32)\n"
          packedUint32ElementIndex++
      }
      var packedUint64ElementIndex:Int = 0
      for oneValuePackedUint64 in packedUint64  {
          output += "\(indent) packedUint64[\(packedUint64ElementIndex)]: \(oneValuePackedUint64)\n"
          packedUint64ElementIndex++
      }
      var packedSint32ElementIndex:Int = 0
      for oneValuePackedSint32 in packedSint32  {
          output += "\(indent) packedSint32[\(packedSint32ElementIndex)]: \(oneValuePackedSint32)\n"
          packedSint32ElementIndex++
      }
      var packedSint64ElementIndex:Int = 0
      for oneValuePackedSint64 in packedSint64  {
          output += "\(indent) packedSint64[\(packedSint64ElementIndex)]: \(oneValuePackedSint64)\n"
          packedSint64ElementIndex++
      }
      var packedFixed32ElementIndex:Int = 0
      for oneValuePackedFixed32 in packedFixed32  {
          output += "\(indent) packedFixed32[\(packedFixed32ElementIndex)]: \(oneValuePackedFixed32)\n"
          packedFixed32ElementIndex++
      }
      var packedFixed64ElementIndex:Int = 0
      for oneValuePackedFixed64 in packedFixed64  {
          output += "\(indent) packedFixed64[\(packedFixed64ElementIndex)]: \(oneValuePackedFixed64)\n"
          packedFixed64ElementIndex++
      }
      var packedSfixed32ElementIndex:Int = 0
      for oneValuePackedSfixed32 in packedSfixed32  {
          output += "\(indent) packedSfixed32[\(packedSfixed32ElementIndex)]: \(oneValuePackedSfixed32)\n"
          packedSfixed32ElementIndex++
      }
      var packedSfixed64ElementIndex:Int = 0
      for oneValuePackedSfixed64 in packedSfixed64  {
          output += "\(indent) packedSfixed64[\(packedSfixed64ElementIndex)]: \(oneValuePackedSfixed64)\n"
          packedSfixed64ElementIndex++
      }
      var packedFloatElementIndex:Int = 0
      for oneValuePackedFloat in packedFloat  {
          output += "\(indent) packedFloat[\(packedFloatElementIndex)]: \(oneValuePackedFloat)\n"
          packedFloatElementIndex++
      }
      var packedDoubleElementIndex:Int = 0
      for oneValuePackedDouble in packedDouble  {
          output += "\(indent) packedDouble[\(packedDoubleElementIndex)]: \(oneValuePackedDouble)\n"
          packedDoubleElementIndex++
      }
      var packedBoolElementIndex:Int = 0
      for oneValuePackedBool in packedBool  {
          output += "\(indent) packedBool[\(packedBoolElementIndex)]: \(oneValuePackedBool)\n"
          packedBoolElementIndex++
      }
      var packedEnumElementIndex:Int = 0
      for oneValueOfpackedEnum in packedEnum {
          output += "\(indent) packedEnum[\(packedEnumElementIndex)]: \(oneValueOfpackedEnum.rawValue)\n"
          packedEnumElementIndex++
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneValuePackedInt32 in packedInt32 {
                hashCode = (hashCode &* 31) &+ oneValuePackedInt32.hashValue
            }
            for oneValuePackedInt64 in packedInt64 {
                hashCode = (hashCode &* 31) &+ oneValuePackedInt64.hashValue
            }
            for oneValuePackedUint32 in packedUint32 {
                hashCode = (hashCode &* 31) &+ oneValuePackedUint32.hashValue
            }
            for oneValuePackedUint64 in packedUint64 {
                hashCode = (hashCode &* 31) &+ oneValuePackedUint64.hashValue
            }
            for oneValuePackedSint32 in packedSint32 {
                hashCode = (hashCode &* 31) &+ oneValuePackedSint32.hashValue
            }
            for oneValuePackedSint64 in packedSint64 {
                hashCode = (hashCode &* 31) &+ oneValuePackedSint64.hashValue
            }
            for oneValuePackedFixed32 in packedFixed32 {
                hashCode = (hashCode &* 31) &+ oneValuePackedFixed32.hashValue
            }
            for oneValuePackedFixed64 in packedFixed64 {
                hashCode = (hashCode &* 31) &+ oneValuePackedFixed64.hashValue
            }
            for oneValuePackedSfixed32 in packedSfixed32 {
                hashCode = (hashCode &* 31) &+ oneValuePackedSfixed32.hashValue
            }
            for oneValuePackedSfixed64 in packedSfixed64 {
                hashCode = (hashCode &* 31) &+ oneValuePackedSfixed64.hashValue
            }
            for oneValuePackedFloat in packedFloat {
                hashCode = (hashCode &* 31) &+ oneValuePackedFloat.hashValue
            }
            for oneValuePackedDouble in packedDouble {
                hashCode = (hashCode &* 31) &+ oneValuePackedDouble.hashValue
            }
            for oneValuePackedBool in packedBool {
                hashCode = (hashCode &* 31) &+ oneValuePackedBool.hashValue
            }
            for oneValueOfpackedEnum in packedEnum {
                hashCode = (hashCode &* 31) &+ Int(oneValueOfpackedEnum.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Proto3ArenaUnittest.TestPackedTypes"
    }
    override public func className() -> String {
        return "Proto3ArenaUnittest.TestPackedTypes"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Proto3ArenaUnittest.TestPackedTypes.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Proto3ArenaUnittest.TestPackedTypes = Proto3ArenaUnittest.TestPackedTypes()
      public func getMessage() -> Proto3ArenaUnittest.TestPackedTypes {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var packedInt32:Array<Int32> {
           get {
               return builderResult.packedInt32
           }
           set (array) {
               builderResult.packedInt32 = array
           }
      }
      public func setPackedInt32(value:Array<Int32>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedInt32 = value
        return self
      }
      public func clearPackedInt32() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedInt32.removeAll(keepCapacity: false)
         return self
      }
      public var packedInt64:Array<Int64> {
           get {
               return builderResult.packedInt64
           }
           set (array) {
               builderResult.packedInt64 = array
           }
      }
      public func setPackedInt64(value:Array<Int64>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedInt64 = value
        return self
      }
      public func clearPackedInt64() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedInt64.removeAll(keepCapacity: false)
         return self
      }
      public var packedUint32:Array<UInt32> {
           get {
               return builderResult.packedUint32
           }
           set (array) {
               builderResult.packedUint32 = array
           }
      }
      public func setPackedUint32(value:Array<UInt32>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedUint32 = value
        return self
      }
      public func clearPackedUint32() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedUint32.removeAll(keepCapacity: false)
         return self
      }
      public var packedUint64:Array<UInt64> {
           get {
               return builderResult.packedUint64
           }
           set (array) {
               builderResult.packedUint64 = array
           }
      }
      public func setPackedUint64(value:Array<UInt64>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedUint64 = value
        return self
      }
      public func clearPackedUint64() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedUint64.removeAll(keepCapacity: false)
         return self
      }
      public var packedSint32:Array<Int32> {
           get {
               return builderResult.packedSint32
           }
           set (array) {
               builderResult.packedSint32 = array
           }
      }
      public func setPackedSint32(value:Array<Int32>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedSint32 = value
        return self
      }
      public func clearPackedSint32() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedSint32.removeAll(keepCapacity: false)
         return self
      }
      public var packedSint64:Array<Int64> {
           get {
               return builderResult.packedSint64
           }
           set (array) {
               builderResult.packedSint64 = array
           }
      }
      public func setPackedSint64(value:Array<Int64>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedSint64 = value
        return self
      }
      public func clearPackedSint64() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedSint64.removeAll(keepCapacity: false)
         return self
      }
      public var packedFixed32:Array<UInt32> {
           get {
               return builderResult.packedFixed32
           }
           set (array) {
               builderResult.packedFixed32 = array
           }
      }
      public func setPackedFixed32(value:Array<UInt32>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedFixed32 = value
        return self
      }
      public func clearPackedFixed32() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedFixed32.removeAll(keepCapacity: false)
         return self
      }
      public var packedFixed64:Array<UInt64> {
           get {
               return builderResult.packedFixed64
           }
           set (array) {
               builderResult.packedFixed64 = array
           }
      }
      public func setPackedFixed64(value:Array<UInt64>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedFixed64 = value
        return self
      }
      public func clearPackedFixed64() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedFixed64.removeAll(keepCapacity: false)
         return self
      }
      public var packedSfixed32:Array<Int32> {
           get {
               return builderResult.packedSfixed32
           }
           set (array) {
               builderResult.packedSfixed32 = array
           }
      }
      public func setPackedSfixed32(value:Array<Int32>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedSfixed32 = value
        return self
      }
      public func clearPackedSfixed32() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedSfixed32.removeAll(keepCapacity: false)
         return self
      }
      public var packedSfixed64:Array<Int64> {
           get {
               return builderResult.packedSfixed64
           }
           set (array) {
               builderResult.packedSfixed64 = array
           }
      }
      public func setPackedSfixed64(value:Array<Int64>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedSfixed64 = value
        return self
      }
      public func clearPackedSfixed64() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedSfixed64.removeAll(keepCapacity: false)
         return self
      }
      public var packedFloat:Array<Float> {
           get {
               return builderResult.packedFloat
           }
           set (array) {
               builderResult.packedFloat = array
           }
      }
      public func setPackedFloat(value:Array<Float>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedFloat = value
        return self
      }
      public func clearPackedFloat() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedFloat.removeAll(keepCapacity: false)
         return self
      }
      public var packedDouble:Array<Double> {
           get {
               return builderResult.packedDouble
           }
           set (array) {
               builderResult.packedDouble = array
           }
      }
      public func setPackedDouble(value:Array<Double>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedDouble = value
        return self
      }
      public func clearPackedDouble() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedDouble.removeAll(keepCapacity: false)
         return self
      }
      public var packedBool:Array<Bool> {
           get {
               return builderResult.packedBool
           }
           set (array) {
               builderResult.packedBool = array
           }
      }
      public func setPackedBool(value:Array<Bool>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedBool = value
        return self
      }
      public func clearPackedBool() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
         builderResult.packedBool.removeAll(keepCapacity: false)
         return self
      }
      public var packedEnum:Array<Proto3ArenaUnittest.ForeignEnum> {
          get {
              return builderResult.packedEnum
          }
          set (value) {
              builderResult.packedEnum = value
          }
      }
      public func setPackedEnum(value:Array<Proto3ArenaUnittest.ForeignEnum>) -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        self.packedEnum = value
        return self
      }
      public func clearPackedEnum() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        builderResult.packedEnum.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        builderResult = Proto3ArenaUnittest.TestPackedTypes()
        return self
      }
      override public func clone() throws -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        return try Proto3ArenaUnittest.TestPackedTypes.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Proto3ArenaUnittest.TestPackedTypes {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Proto3ArenaUnittest.TestPackedTypes {
        let returnMe:Proto3ArenaUnittest.TestPackedTypes = builderResult
        return returnMe
      }
      public func mergeFrom(other:Proto3ArenaUnittest.TestPackedTypes) throws -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        if other == Proto3ArenaUnittest.TestPackedTypes() {
         return self
        }
        if !other.packedInt32.isEmpty {
            builderResult.packedInt32 += other.packedInt32
        }
        if !other.packedInt64.isEmpty {
            builderResult.packedInt64 += other.packedInt64
        }
        if !other.packedUint32.isEmpty {
            builderResult.packedUint32 += other.packedUint32
        }
        if !other.packedUint64.isEmpty {
            builderResult.packedUint64 += other.packedUint64
        }
        if !other.packedSint32.isEmpty {
            builderResult.packedSint32 += other.packedSint32
        }
        if !other.packedSint64.isEmpty {
            builderResult.packedSint64 += other.packedSint64
        }
        if !other.packedFixed32.isEmpty {
            builderResult.packedFixed32 += other.packedFixed32
        }
        if !other.packedFixed64.isEmpty {
            builderResult.packedFixed64 += other.packedFixed64
        }
        if !other.packedSfixed32.isEmpty {
            builderResult.packedSfixed32 += other.packedSfixed32
        }
        if !other.packedSfixed64.isEmpty {
            builderResult.packedSfixed64 += other.packedSfixed64
        }
        if !other.packedFloat.isEmpty {
            builderResult.packedFloat += other.packedFloat
        }
        if !other.packedDouble.isEmpty {
            builderResult.packedDouble += other.packedDouble
        }
        if !other.packedBool.isEmpty {
            builderResult.packedBool += other.packedBool
        }
        if !other.packedEnum.isEmpty {
           builderResult.packedEnum += other.packedEnum
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.TestPackedTypes.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 722 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedInt32 += [try input.readInt32()]
            }
            input.popLimit(limit)

          case 730 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedInt64 += [try input.readInt64()]
            }
            input.popLimit(limit)

          case 738 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedUint32 += [try input.readUInt32()]
            }
            input.popLimit(limit)

          case 746 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedUint64 += [try input.readUInt64()]
            }
            input.popLimit(limit)

          case 754 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedSint32 += [try input.readSInt32()]
            }
            input.popLimit(limit)

          case 762 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedSint64 += [try input.readSInt64()]
            }
            input.popLimit(limit)

          case 770 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedFixed32 += [try input.readFixed32()]
            }
            input.popLimit(limit)

          case 778 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedFixed64 += [try input.readFixed64()]
            }
            input.popLimit(limit)

          case 786 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedSfixed32 += [try input.readSFixed32()]
            }
            input.popLimit(limit)

          case 794 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedSfixed64 += [try input.readSFixed64()]
            }
            input.popLimit(limit)

          case 802 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedFloat += [try input.readFloat()]
            }
            input.popLimit(limit)

          case 810 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedDouble += [try input.readDouble()]
            }
            input.popLimit(limit)

          case 818 :
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.packedBool += [try input.readBool()]
            }
            input.popLimit(limit)

          case 826 :
            let length:Int32 = try input.readRawVarint32()
            let oldLimit:Int32 = try input.pushLimit(length)
            while input.bytesUntilLimit() > 0 {
            let valueIntpackedEnum = try input.readEnum()
            if let enumspackedEnum = Proto3ArenaUnittest.ForeignEnum(rawValue:valueIntpackedEnum) {
                 builderResult.packedEnum += [enumspackedEnum]
            } else {
                 try unknownFieldsBuilder.mergeVarintField(103, value:Int64(valueIntpackedEnum))
            }
            }
            input.popLimit(oldLimit)

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        let resultDecodedBuilder = Proto3ArenaUnittest.TestPackedTypes.Builder()
        if let jsonValuePackedInt32 = jsonMap["packedInt32"] as? Array<NSNumber> {
          var jsonArrayPackedInt32:Array<Int32> = []
          for oneValuePackedInt32 in jsonValuePackedInt32 {
            jsonArrayPackedInt32 += [oneValuePackedInt32.intValue]
          }
          resultDecodedBuilder.packedInt32 = jsonArrayPackedInt32
        }
        if let jsonValuePackedInt64 = jsonMap["packedInt64"] as? Array<String> {
          var jsonArrayPackedInt64:Array<Int64> = []
          for oneValuePackedInt64 in jsonValuePackedInt64 {
            jsonArrayPackedInt64 += [Int64(oneValuePackedInt64)!]
          }
          resultDecodedBuilder.packedInt64 = jsonArrayPackedInt64
        }
        if let jsonValuePackedUint32 = jsonMap["packedUint32"] as? Array<NSNumber> {
          var jsonArrayPackedUint32:Array<UInt32> = []
          for oneValuePackedUint32 in jsonValuePackedUint32 {
            jsonArrayPackedUint32 += [oneValuePackedUint32.unsignedIntValue]
          }
          resultDecodedBuilder.packedUint32 = jsonArrayPackedUint32
        }
        if let jsonValuePackedUint64 = jsonMap["packedUint64"] as? Array<String> {
          var jsonArrayPackedUint64:Array<UInt64> = []
          for oneValuePackedUint64 in jsonValuePackedUint64 {
            jsonArrayPackedUint64 += [UInt64(oneValuePackedUint64)!]
          }
          resultDecodedBuilder.packedUint64 = jsonArrayPackedUint64
        }
        if let jsonValuePackedSint32 = jsonMap["packedSint32"] as? Array<NSNumber> {
          var jsonArrayPackedSint32:Array<Int32> = []
          for oneValuePackedSint32 in jsonValuePackedSint32 {
            jsonArrayPackedSint32 += [oneValuePackedSint32.intValue]
          }
          resultDecodedBuilder.packedSint32 = jsonArrayPackedSint32
        }
        if let jsonValuePackedSint64 = jsonMap["packedSint64"] as? Array<String> {
          var jsonArrayPackedSint64:Array<Int64> = []
          for oneValuePackedSint64 in jsonValuePackedSint64 {
            jsonArrayPackedSint64 += [Int64(oneValuePackedSint64)!]
          }
          resultDecodedBuilder.packedSint64 = jsonArrayPackedSint64
        }
        if let jsonValuePackedFixed32 = jsonMap["packedFixed32"] as? Array<NSNumber> {
          var jsonArrayPackedFixed32:Array<UInt32> = []
          for oneValuePackedFixed32 in jsonValuePackedFixed32 {
            jsonArrayPackedFixed32 += [oneValuePackedFixed32.unsignedIntValue]
          }
          resultDecodedBuilder.packedFixed32 = jsonArrayPackedFixed32
        }
        if let jsonValuePackedFixed64 = jsonMap["packedFixed64"] as? Array<String> {
          var jsonArrayPackedFixed64:Array<UInt64> = []
          for oneValuePackedFixed64 in jsonValuePackedFixed64 {
            jsonArrayPackedFixed64 += [UInt64(oneValuePackedFixed64)!]
          }
          resultDecodedBuilder.packedFixed64 = jsonArrayPackedFixed64
        }
        if let jsonValuePackedSfixed32 = jsonMap["packedSfixed32"] as? Array<NSNumber> {
          var jsonArrayPackedSfixed32:Array<Int32> = []
          for oneValuePackedSfixed32 in jsonValuePackedSfixed32 {
            jsonArrayPackedSfixed32 += [oneValuePackedSfixed32.intValue]
          }
          resultDecodedBuilder.packedSfixed32 = jsonArrayPackedSfixed32
        }
        if let jsonValuePackedSfixed64 = jsonMap["packedSfixed64"] as? Array<String> {
          var jsonArrayPackedSfixed64:Array<Int64> = []
          for oneValuePackedSfixed64 in jsonValuePackedSfixed64 {
            jsonArrayPackedSfixed64 += [Int64(oneValuePackedSfixed64)!]
          }
          resultDecodedBuilder.packedSfixed64 = jsonArrayPackedSfixed64
        }
        if let jsonValuePackedFloat = jsonMap["packedFloat"] as? Array<NSNumber> {
          var jsonArrayPackedFloat:Array<Float> = []
          for oneValuePackedFloat in jsonValuePackedFloat {
            jsonArrayPackedFloat += [oneValuePackedFloat.floatValue]
          }
          resultDecodedBuilder.packedFloat = jsonArrayPackedFloat
        }
        if let jsonValuePackedDouble = jsonMap["packedDouble"] as? Array<NSNumber> {
          var jsonArrayPackedDouble:Array<Double> = []
          for oneValuePackedDouble in jsonValuePackedDouble {
            jsonArrayPackedDouble += [oneValuePackedDouble.doubleValue]
          }
          resultDecodedBuilder.packedDouble = jsonArrayPackedDouble
        }
        if let jsonValuePackedBool = jsonMap["packedBool"] as? Array<Bool> {
          resultDecodedBuilder.packedBool = jsonValuePackedBool
        }
        if let jsonValuePackedEnum = jsonMap["packedEnum"] as? Array<String> {
          var jsonArrayPackedEnum:Array<Proto3ArenaUnittest.ForeignEnum> = []
          for oneValuePackedEnum in jsonValuePackedEnum {
            let enumFromStringPackedEnum = try Proto3ArenaUnittest.ForeignEnum.fromString(oneValuePackedEnum)
            jsonArrayPackedEnum += [enumFromStringPackedEnum]
          }
          resultDecodedBuilder.packedEnum = jsonArrayPackedEnum
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Proto3ArenaUnittest.TestPackedTypes.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Proto3ArenaUnittest.TestPackedTypes.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // Explicitly set packed to false
  final public class TestUnpackedTypes : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var repeatedInt32:Array<Int32> = Array<Int32>()
    public private(set) var repeatedInt64:Array<Int64> = Array<Int64>()
    public private(set) var repeatedUint32:Array<UInt32> = Array<UInt32>()
    public private(set) var repeatedUint64:Array<UInt64> = Array<UInt64>()
    public private(set) var repeatedSint32:Array<Int32> = Array<Int32>()
    public private(set) var repeatedSint64:Array<Int64> = Array<Int64>()
    public private(set) var repeatedFixed32:Array<UInt32> = Array<UInt32>()
    public private(set) var repeatedFixed64:Array<UInt64> = Array<UInt64>()
    public private(set) var repeatedSfixed32:Array<Int32> = Array<Int32>()
    public private(set) var repeatedSfixed64:Array<Int64> = Array<Int64>()
    public private(set) var repeatedFloat:Array<Float> = Array<Float>()
    public private(set) var repeatedDouble:Array<Double> = Array<Double>()
    public private(set) var repeatedBool:Array<Bool> = Array<Bool>()
    private var repeatedNestedEnumMemoizedSerializedSize:Int32 = 0
    public private(set) var repeatedNestedEnum:Array<Proto3ArenaUnittest.TestAllTypes.NestedEnum> = Array<Proto3ArenaUnittest.TestAllTypes.NestedEnum>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if !repeatedInt32.isEmpty {
        for oneValuerepeatedInt32 in repeatedInt32 {
          try output.writeInt32(1, value:oneValuerepeatedInt32)
        }
      }
      if !repeatedInt64.isEmpty {
        for oneValuerepeatedInt64 in repeatedInt64 {
          try output.writeInt64(2, value:oneValuerepeatedInt64)
        }
      }
      if !repeatedUint32.isEmpty {
        for oneValuerepeatedUint32 in repeatedUint32 {
          try output.writeUInt32(3, value:oneValuerepeatedUint32)
        }
      }
      if !repeatedUint64.isEmpty {
        for oneValuerepeatedUint64 in repeatedUint64 {
          try output.writeUInt64(4, value:oneValuerepeatedUint64)
        }
      }
      if !repeatedSint32.isEmpty {
        for oneValuerepeatedSint32 in repeatedSint32 {
          try output.writeSInt32(5, value:oneValuerepeatedSint32)
        }
      }
      if !repeatedSint64.isEmpty {
        for oneValuerepeatedSint64 in repeatedSint64 {
          try output.writeSInt64(6, value:oneValuerepeatedSint64)
        }
      }
      if !repeatedFixed32.isEmpty {
        for oneValuerepeatedFixed32 in repeatedFixed32 {
          try output.writeFixed32(7, value:oneValuerepeatedFixed32)
        }
      }
      if !repeatedFixed64.isEmpty {
        for oneValuerepeatedFixed64 in repeatedFixed64 {
          try output.writeFixed64(8, value:oneValuerepeatedFixed64)
        }
      }
      if !repeatedSfixed32.isEmpty {
        for oneValuerepeatedSfixed32 in repeatedSfixed32 {
          try output.writeSFixed32(9, value:oneValuerepeatedSfixed32)
        }
      }
      if !repeatedSfixed64.isEmpty {
        for oneValuerepeatedSfixed64 in repeatedSfixed64 {
          try output.writeSFixed64(10, value:oneValuerepeatedSfixed64)
        }
      }
      if !repeatedFloat.isEmpty {
        for oneValuerepeatedFloat in repeatedFloat {
          try output.writeFloat(11, value:oneValuerepeatedFloat)
        }
      }
      if !repeatedDouble.isEmpty {
        for oneValuerepeatedDouble in repeatedDouble {
          try output.writeDouble(12, value:oneValuerepeatedDouble)
        }
      }
      if !repeatedBool.isEmpty {
        for oneValuerepeatedBool in repeatedBool {
          try output.writeBool(13, value:oneValuerepeatedBool)
        }
      }
      for oneValueOfrepeatedNestedEnum in repeatedNestedEnum {
          try output.writeEnum(14, value:oneValueOfrepeatedNestedEnum.rawValue)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      var dataSizeRepeatedInt32:Int32 = 0
      for oneValuerepeatedInt32 in repeatedInt32 {
          dataSizeRepeatedInt32 += oneValuerepeatedInt32.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeRepeatedInt32
      serialize_size += 1 * Int32(repeatedInt32.count)
      var dataSizeRepeatedInt64:Int32 = 0
      for oneValuerepeatedInt64 in repeatedInt64 {
          dataSizeRepeatedInt64 += oneValuerepeatedInt64.computeInt64SizeNoTag()
      }
      serialize_size += dataSizeRepeatedInt64
      serialize_size += 1 * Int32(repeatedInt64.count)
      var dataSizeRepeatedUint32:Int32 = 0
      for oneValuerepeatedUint32 in repeatedUint32 {
          dataSizeRepeatedUint32 += oneValuerepeatedUint32.computeUInt32SizeNoTag()
      }
      serialize_size += dataSizeRepeatedUint32
      serialize_size += 1 * Int32(repeatedUint32.count)
      var dataSizeRepeatedUint64:Int32 = 0
      for oneValuerepeatedUint64 in repeatedUint64 {
          dataSizeRepeatedUint64 += oneValuerepeatedUint64.computeUInt64SizeNoTag()
      }
      serialize_size += dataSizeRepeatedUint64
      serialize_size += 1 * Int32(repeatedUint64.count)
      var dataSizeRepeatedSint32:Int32 = 0
      for oneValuerepeatedSint32 in repeatedSint32 {
          dataSizeRepeatedSint32 += oneValuerepeatedSint32.computeSInt32SizeNoTag()
      }
      serialize_size += dataSizeRepeatedSint32
      serialize_size += 1 * Int32(repeatedSint32.count)
      var dataSizeRepeatedSint64:Int32 = 0
      for oneValuerepeatedSint64 in repeatedSint64 {
          dataSizeRepeatedSint64 += oneValuerepeatedSint64.computeSInt64SizeNoTag()
      }
      serialize_size += dataSizeRepeatedSint64
      serialize_size += 1 * Int32(repeatedSint64.count)
      var dataSizeRepeatedFixed32:Int32 = 0
      dataSizeRepeatedFixed32 = 4 * Int32(repeatedFixed32.count)
      serialize_size += dataSizeRepeatedFixed32
      serialize_size += 1 * Int32(repeatedFixed32.count)
      var dataSizeRepeatedFixed64:Int32 = 0
      dataSizeRepeatedFixed64 = 8 * Int32(repeatedFixed64.count)
      serialize_size += dataSizeRepeatedFixed64
      serialize_size += 1 * Int32(repeatedFixed64.count)
      var dataSizeRepeatedSfixed32:Int32 = 0
      dataSizeRepeatedSfixed32 = 4 * Int32(repeatedSfixed32.count)
      serialize_size += dataSizeRepeatedSfixed32
      serialize_size += 1 * Int32(repeatedSfixed32.count)
      var dataSizeRepeatedSfixed64:Int32 = 0
      dataSizeRepeatedSfixed64 = 8 * Int32(repeatedSfixed64.count)
      serialize_size += dataSizeRepeatedSfixed64
      serialize_size += 1 * Int32(repeatedSfixed64.count)
      var dataSizeRepeatedFloat:Int32 = 0
      dataSizeRepeatedFloat = 4 * Int32(repeatedFloat.count)
      serialize_size += dataSizeRepeatedFloat
      serialize_size += 1 * Int32(repeatedFloat.count)
      var dataSizeRepeatedDouble:Int32 = 0
      dataSizeRepeatedDouble = 8 * Int32(repeatedDouble.count)
      serialize_size += dataSizeRepeatedDouble
      serialize_size += 1 * Int32(repeatedDouble.count)
      var dataSizeRepeatedBool:Int32 = 0
      dataSizeRepeatedBool = 1 * Int32(repeatedBool.count)
      serialize_size += dataSizeRepeatedBool
      serialize_size += 1 * Int32(repeatedBool.count)
      var dataSizerepeatedNestedEnum:Int32 = 0
      for oneValueOfrepeatedNestedEnum in repeatedNestedEnum {
          dataSizerepeatedNestedEnum += oneValueOfrepeatedNestedEnum.rawValue.computeEnumSizeNoTag()
      }
      serialize_size += dataSizerepeatedNestedEnum
      serialize_size += (1 * Int32(repeatedNestedEnum.count))
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Proto3ArenaUnittest.TestUnpackedTypes> {
      var mergedArray = Array<Proto3ArenaUnittest.TestUnpackedTypes>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.TestUnpackedTypes? {
      return try Proto3ArenaUnittest.TestUnpackedTypes.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Proto3ArenaUnittest.TestUnpackedTypes {
      return try Proto3ArenaUnittest.TestUnpackedTypes.Builder().mergeFromData(data, extensionRegistry:Proto3ArenaUnittest.UnittestProto3ArenaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestUnpackedTypes {
      return try Proto3ArenaUnittest.TestUnpackedTypes.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.TestUnpackedTypes {
      return try Proto3ArenaUnittest.TestUnpackedTypes.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestUnpackedTypes {
      return try Proto3ArenaUnittest.TestUnpackedTypes.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.TestUnpackedTypes {
      return try Proto3ArenaUnittest.TestUnpackedTypes.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestUnpackedTypes {
      return try Proto3ArenaUnittest.TestUnpackedTypes.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
      return Proto3ArenaUnittest.TestUnpackedTypes.classBuilder() as! Proto3ArenaUnittest.TestUnpackedTypes.Builder
    }
    public func getBuilder() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
      return classBuilder() as! Proto3ArenaUnittest.TestUnpackedTypes.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Proto3ArenaUnittest.TestUnpackedTypes.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Proto3ArenaUnittest.TestUnpackedTypes.Builder()
    }
    public func toBuilder() throws -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
      return try Proto3ArenaUnittest.TestUnpackedTypes.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Proto3ArenaUnittest.TestUnpackedTypes) throws -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
      return try Proto3ArenaUnittest.TestUnpackedTypes.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if !repeatedInt32.isEmpty {
        var jsonArrayRepeatedInt32:Array<NSNumber> = []
          for oneValueRepeatedInt32 in repeatedInt32 {
            jsonArrayRepeatedInt32 += [NSNumber(int:oneValueRepeatedInt32)]
          }
        jsonMap["repeatedInt32"] = jsonArrayRepeatedInt32
      }
      if !repeatedInt64.isEmpty {
        var jsonArrayRepeatedInt64:Array<String> = []
          for oneValueRepeatedInt64 in repeatedInt64 {
            jsonArrayRepeatedInt64 += ["\(oneValueRepeatedInt64)"]
          }
        jsonMap["repeatedInt64"] = jsonArrayRepeatedInt64
      }
      if !repeatedUint32.isEmpty {
        var jsonArrayRepeatedUint32:Array<NSNumber> = []
          for oneValueRepeatedUint32 in repeatedUint32 {
            jsonArrayRepeatedUint32 += [NSNumber(unsignedInt:oneValueRepeatedUint32)]
          }
        jsonMap["repeatedUint32"] = jsonArrayRepeatedUint32
      }
      if !repeatedUint64.isEmpty {
        var jsonArrayRepeatedUint64:Array<String> = []
          for oneValueRepeatedUint64 in repeatedUint64 {
            jsonArrayRepeatedUint64 += ["\(oneValueRepeatedUint64)"]
          }
        jsonMap["repeatedUint64"] = jsonArrayRepeatedUint64
      }
      if !repeatedSint32.isEmpty {
        var jsonArrayRepeatedSint32:Array<NSNumber> = []
          for oneValueRepeatedSint32 in repeatedSint32 {
            jsonArrayRepeatedSint32 += [NSNumber(int:oneValueRepeatedSint32)]
          }
        jsonMap["repeatedSint32"] = jsonArrayRepeatedSint32
      }
      if !repeatedSint64.isEmpty {
        var jsonArrayRepeatedSint64:Array<String> = []
          for oneValueRepeatedSint64 in repeatedSint64 {
            jsonArrayRepeatedSint64 += ["\(oneValueRepeatedSint64)"]
          }
        jsonMap["repeatedSint64"] = jsonArrayRepeatedSint64
      }
      if !repeatedFixed32.isEmpty {
        var jsonArrayRepeatedFixed32:Array<NSNumber> = []
          for oneValueRepeatedFixed32 in repeatedFixed32 {
            jsonArrayRepeatedFixed32 += [NSNumber(unsignedInt:oneValueRepeatedFixed32)]
          }
        jsonMap["repeatedFixed32"] = jsonArrayRepeatedFixed32
      }
      if !repeatedFixed64.isEmpty {
        var jsonArrayRepeatedFixed64:Array<String> = []
          for oneValueRepeatedFixed64 in repeatedFixed64 {
            jsonArrayRepeatedFixed64 += ["\(oneValueRepeatedFixed64)"]
          }
        jsonMap["repeatedFixed64"] = jsonArrayRepeatedFixed64
      }
      if !repeatedSfixed32.isEmpty {
        var jsonArrayRepeatedSfixed32:Array<NSNumber> = []
          for oneValueRepeatedSfixed32 in repeatedSfixed32 {
            jsonArrayRepeatedSfixed32 += [NSNumber(int:oneValueRepeatedSfixed32)]
          }
        jsonMap["repeatedSfixed32"] = jsonArrayRepeatedSfixed32
      }
      if !repeatedSfixed64.isEmpty {
        var jsonArrayRepeatedSfixed64:Array<String> = []
          for oneValueRepeatedSfixed64 in repeatedSfixed64 {
            jsonArrayRepeatedSfixed64 += ["\(oneValueRepeatedSfixed64)"]
          }
        jsonMap["repeatedSfixed64"] = jsonArrayRepeatedSfixed64
      }
      if !repeatedFloat.isEmpty {
        var jsonArrayRepeatedFloat:Array<NSNumber> = []
          for oneValueRepeatedFloat in repeatedFloat {
            jsonArrayRepeatedFloat += [NSNumber(float:oneValueRepeatedFloat)]
          }
        jsonMap["repeatedFloat"] = jsonArrayRepeatedFloat
      }
      if !repeatedDouble.isEmpty {
        var jsonArrayRepeatedDouble:Array<NSNumber> = []
          for oneValueRepeatedDouble in repeatedDouble {
            jsonArrayRepeatedDouble += [NSNumber(double:oneValueRepeatedDouble)]
          }
        jsonMap["repeatedDouble"] = jsonArrayRepeatedDouble
      }
      if !repeatedBool.isEmpty {
        jsonMap["repeatedBool"] = repeatedBool
      }
      if !repeatedNestedEnum.isEmpty {
        var jsonArrayRepeatedNestedEnum:Array<String> = []
          for oneValueRepeatedNestedEnum in repeatedNestedEnum {
            jsonArrayRepeatedNestedEnum += [oneValueRepeatedNestedEnum.toString()]
          }
        jsonMap["repeatedNestedEnum"] = jsonArrayRepeatedNestedEnum
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.TestUnpackedTypes {
      return try Proto3ArenaUnittest.TestUnpackedTypes.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Proto3ArenaUnittest.TestUnpackedTypes {
      return try Proto3ArenaUnittest.TestUnpackedTypes.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var repeatedInt32ElementIndex:Int = 0
      for oneValueRepeatedInt32 in repeatedInt32  {
          output += "\(indent) repeatedInt32[\(repeatedInt32ElementIndex)]: \(oneValueRepeatedInt32)\n"
          repeatedInt32ElementIndex++
      }
      var repeatedInt64ElementIndex:Int = 0
      for oneValueRepeatedInt64 in repeatedInt64  {
          output += "\(indent) repeatedInt64[\(repeatedInt64ElementIndex)]: \(oneValueRepeatedInt64)\n"
          repeatedInt64ElementIndex++
      }
      var repeatedUint32ElementIndex:Int = 0
      for oneValueRepeatedUint32 in repeatedUint32  {
          output += "\(indent) repeatedUint32[\(repeatedUint32ElementIndex)]: \(oneValueRepeatedUint32)\n"
          repeatedUint32ElementIndex++
      }
      var repeatedUint64ElementIndex:Int = 0
      for oneValueRepeatedUint64 in repeatedUint64  {
          output += "\(indent) repeatedUint64[\(repeatedUint64ElementIndex)]: \(oneValueRepeatedUint64)\n"
          repeatedUint64ElementIndex++
      }
      var repeatedSint32ElementIndex:Int = 0
      for oneValueRepeatedSint32 in repeatedSint32  {
          output += "\(indent) repeatedSint32[\(repeatedSint32ElementIndex)]: \(oneValueRepeatedSint32)\n"
          repeatedSint32ElementIndex++
      }
      var repeatedSint64ElementIndex:Int = 0
      for oneValueRepeatedSint64 in repeatedSint64  {
          output += "\(indent) repeatedSint64[\(repeatedSint64ElementIndex)]: \(oneValueRepeatedSint64)\n"
          repeatedSint64ElementIndex++
      }
      var repeatedFixed32ElementIndex:Int = 0
      for oneValueRepeatedFixed32 in repeatedFixed32  {
          output += "\(indent) repeatedFixed32[\(repeatedFixed32ElementIndex)]: \(oneValueRepeatedFixed32)\n"
          repeatedFixed32ElementIndex++
      }
      var repeatedFixed64ElementIndex:Int = 0
      for oneValueRepeatedFixed64 in repeatedFixed64  {
          output += "\(indent) repeatedFixed64[\(repeatedFixed64ElementIndex)]: \(oneValueRepeatedFixed64)\n"
          repeatedFixed64ElementIndex++
      }
      var repeatedSfixed32ElementIndex:Int = 0
      for oneValueRepeatedSfixed32 in repeatedSfixed32  {
          output += "\(indent) repeatedSfixed32[\(repeatedSfixed32ElementIndex)]: \(oneValueRepeatedSfixed32)\n"
          repeatedSfixed32ElementIndex++
      }
      var repeatedSfixed64ElementIndex:Int = 0
      for oneValueRepeatedSfixed64 in repeatedSfixed64  {
          output += "\(indent) repeatedSfixed64[\(repeatedSfixed64ElementIndex)]: \(oneValueRepeatedSfixed64)\n"
          repeatedSfixed64ElementIndex++
      }
      var repeatedFloatElementIndex:Int = 0
      for oneValueRepeatedFloat in repeatedFloat  {
          output += "\(indent) repeatedFloat[\(repeatedFloatElementIndex)]: \(oneValueRepeatedFloat)\n"
          repeatedFloatElementIndex++
      }
      var repeatedDoubleElementIndex:Int = 0
      for oneValueRepeatedDouble in repeatedDouble  {
          output += "\(indent) repeatedDouble[\(repeatedDoubleElementIndex)]: \(oneValueRepeatedDouble)\n"
          repeatedDoubleElementIndex++
      }
      var repeatedBoolElementIndex:Int = 0
      for oneValueRepeatedBool in repeatedBool  {
          output += "\(indent) repeatedBool[\(repeatedBoolElementIndex)]: \(oneValueRepeatedBool)\n"
          repeatedBoolElementIndex++
      }
      var repeatedNestedEnumElementIndex:Int = 0
      for oneValueOfrepeatedNestedEnum in repeatedNestedEnum {
          output += "\(indent) repeatedNestedEnum[\(repeatedNestedEnumElementIndex)]: \(oneValueOfrepeatedNestedEnum.rawValue)\n"
          repeatedNestedEnumElementIndex++
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneValueRepeatedInt32 in repeatedInt32 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedInt32.hashValue
            }
            for oneValueRepeatedInt64 in repeatedInt64 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedInt64.hashValue
            }
            for oneValueRepeatedUint32 in repeatedUint32 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedUint32.hashValue
            }
            for oneValueRepeatedUint64 in repeatedUint64 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedUint64.hashValue
            }
            for oneValueRepeatedSint32 in repeatedSint32 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedSint32.hashValue
            }
            for oneValueRepeatedSint64 in repeatedSint64 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedSint64.hashValue
            }
            for oneValueRepeatedFixed32 in repeatedFixed32 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedFixed32.hashValue
            }
            for oneValueRepeatedFixed64 in repeatedFixed64 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedFixed64.hashValue
            }
            for oneValueRepeatedSfixed32 in repeatedSfixed32 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedSfixed32.hashValue
            }
            for oneValueRepeatedSfixed64 in repeatedSfixed64 {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedSfixed64.hashValue
            }
            for oneValueRepeatedFloat in repeatedFloat {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedFloat.hashValue
            }
            for oneValueRepeatedDouble in repeatedDouble {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedDouble.hashValue
            }
            for oneValueRepeatedBool in repeatedBool {
                hashCode = (hashCode &* 31) &+ oneValueRepeatedBool.hashValue
            }
            for oneValueOfrepeatedNestedEnum in repeatedNestedEnum {
                hashCode = (hashCode &* 31) &+ Int(oneValueOfrepeatedNestedEnum.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Proto3ArenaUnittest.TestUnpackedTypes"
    }
    override public func className() -> String {
        return "Proto3ArenaUnittest.TestUnpackedTypes"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Proto3ArenaUnittest.TestUnpackedTypes.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Proto3ArenaUnittest.TestUnpackedTypes = Proto3ArenaUnittest.TestUnpackedTypes()
      public func getMessage() -> Proto3ArenaUnittest.TestUnpackedTypes {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var repeatedInt32:Array<Int32> {
           get {
               return builderResult.repeatedInt32
           }
           set (array) {
               builderResult.repeatedInt32 = array
           }
      }
      public func setRepeatedInt32(value:Array<Int32>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedInt32 = value
        return self
      }
      public func clearRepeatedInt32() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedInt32.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedInt64:Array<Int64> {
           get {
               return builderResult.repeatedInt64
           }
           set (array) {
               builderResult.repeatedInt64 = array
           }
      }
      public func setRepeatedInt64(value:Array<Int64>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedInt64 = value
        return self
      }
      public func clearRepeatedInt64() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedInt64.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedUint32:Array<UInt32> {
           get {
               return builderResult.repeatedUint32
           }
           set (array) {
               builderResult.repeatedUint32 = array
           }
      }
      public func setRepeatedUint32(value:Array<UInt32>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedUint32 = value
        return self
      }
      public func clearRepeatedUint32() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedUint32.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedUint64:Array<UInt64> {
           get {
               return builderResult.repeatedUint64
           }
           set (array) {
               builderResult.repeatedUint64 = array
           }
      }
      public func setRepeatedUint64(value:Array<UInt64>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedUint64 = value
        return self
      }
      public func clearRepeatedUint64() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedUint64.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedSint32:Array<Int32> {
           get {
               return builderResult.repeatedSint32
           }
           set (array) {
               builderResult.repeatedSint32 = array
           }
      }
      public func setRepeatedSint32(value:Array<Int32>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedSint32 = value
        return self
      }
      public func clearRepeatedSint32() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedSint32.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedSint64:Array<Int64> {
           get {
               return builderResult.repeatedSint64
           }
           set (array) {
               builderResult.repeatedSint64 = array
           }
      }
      public func setRepeatedSint64(value:Array<Int64>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedSint64 = value
        return self
      }
      public func clearRepeatedSint64() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedSint64.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedFixed32:Array<UInt32> {
           get {
               return builderResult.repeatedFixed32
           }
           set (array) {
               builderResult.repeatedFixed32 = array
           }
      }
      public func setRepeatedFixed32(value:Array<UInt32>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedFixed32 = value
        return self
      }
      public func clearRepeatedFixed32() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedFixed32.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedFixed64:Array<UInt64> {
           get {
               return builderResult.repeatedFixed64
           }
           set (array) {
               builderResult.repeatedFixed64 = array
           }
      }
      public func setRepeatedFixed64(value:Array<UInt64>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedFixed64 = value
        return self
      }
      public func clearRepeatedFixed64() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedFixed64.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedSfixed32:Array<Int32> {
           get {
               return builderResult.repeatedSfixed32
           }
           set (array) {
               builderResult.repeatedSfixed32 = array
           }
      }
      public func setRepeatedSfixed32(value:Array<Int32>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedSfixed32 = value
        return self
      }
      public func clearRepeatedSfixed32() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedSfixed32.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedSfixed64:Array<Int64> {
           get {
               return builderResult.repeatedSfixed64
           }
           set (array) {
               builderResult.repeatedSfixed64 = array
           }
      }
      public func setRepeatedSfixed64(value:Array<Int64>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedSfixed64 = value
        return self
      }
      public func clearRepeatedSfixed64() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedSfixed64.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedFloat:Array<Float> {
           get {
               return builderResult.repeatedFloat
           }
           set (array) {
               builderResult.repeatedFloat = array
           }
      }
      public func setRepeatedFloat(value:Array<Float>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedFloat = value
        return self
      }
      public func clearRepeatedFloat() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedFloat.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedDouble:Array<Double> {
           get {
               return builderResult.repeatedDouble
           }
           set (array) {
               builderResult.repeatedDouble = array
           }
      }
      public func setRepeatedDouble(value:Array<Double>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedDouble = value
        return self
      }
      public func clearRepeatedDouble() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedDouble.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedBool:Array<Bool> {
           get {
               return builderResult.repeatedBool
           }
           set (array) {
               builderResult.repeatedBool = array
           }
      }
      public func setRepeatedBool(value:Array<Bool>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedBool = value
        return self
      }
      public func clearRepeatedBool() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
         builderResult.repeatedBool.removeAll(keepCapacity: false)
         return self
      }
      public var repeatedNestedEnum:Array<Proto3ArenaUnittest.TestAllTypes.NestedEnum> {
          get {
              return builderResult.repeatedNestedEnum
          }
          set (value) {
              builderResult.repeatedNestedEnum = value
          }
      }
      public func setRepeatedNestedEnum(value:Array<Proto3ArenaUnittest.TestAllTypes.NestedEnum>) -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        self.repeatedNestedEnum = value
        return self
      }
      public func clearRepeatedNestedEnum() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        builderResult.repeatedNestedEnum.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        builderResult = Proto3ArenaUnittest.TestUnpackedTypes()
        return self
      }
      override public func clone() throws -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        return try Proto3ArenaUnittest.TestUnpackedTypes.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Proto3ArenaUnittest.TestUnpackedTypes {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Proto3ArenaUnittest.TestUnpackedTypes {
        let returnMe:Proto3ArenaUnittest.TestUnpackedTypes = builderResult
        return returnMe
      }
      public func mergeFrom(other:Proto3ArenaUnittest.TestUnpackedTypes) throws -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        if other == Proto3ArenaUnittest.TestUnpackedTypes() {
         return self
        }
        if !other.repeatedInt32.isEmpty {
            builderResult.repeatedInt32 += other.repeatedInt32
        }
        if !other.repeatedInt64.isEmpty {
            builderResult.repeatedInt64 += other.repeatedInt64
        }
        if !other.repeatedUint32.isEmpty {
            builderResult.repeatedUint32 += other.repeatedUint32
        }
        if !other.repeatedUint64.isEmpty {
            builderResult.repeatedUint64 += other.repeatedUint64
        }
        if !other.repeatedSint32.isEmpty {
            builderResult.repeatedSint32 += other.repeatedSint32
        }
        if !other.repeatedSint64.isEmpty {
            builderResult.repeatedSint64 += other.repeatedSint64
        }
        if !other.repeatedFixed32.isEmpty {
            builderResult.repeatedFixed32 += other.repeatedFixed32
        }
        if !other.repeatedFixed64.isEmpty {
            builderResult.repeatedFixed64 += other.repeatedFixed64
        }
        if !other.repeatedSfixed32.isEmpty {
            builderResult.repeatedSfixed32 += other.repeatedSfixed32
        }
        if !other.repeatedSfixed64.isEmpty {
            builderResult.repeatedSfixed64 += other.repeatedSfixed64
        }
        if !other.repeatedFloat.isEmpty {
            builderResult.repeatedFloat += other.repeatedFloat
        }
        if !other.repeatedDouble.isEmpty {
            builderResult.repeatedDouble += other.repeatedDouble
        }
        if !other.repeatedBool.isEmpty {
            builderResult.repeatedBool += other.repeatedBool
        }
        if !other.repeatedNestedEnum.isEmpty {
           builderResult.repeatedNestedEnum += other.repeatedNestedEnum
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            repeatedInt32 += [try input.readInt32()]

          case 16 :
            repeatedInt64 += [try input.readInt64()]

          case 24 :
            repeatedUint32 += [try input.readUInt32()]

          case 32 :
            repeatedUint64 += [try input.readUInt64()]

          case 40 :
            repeatedSint32 += [try input.readSInt32()]

          case 48 :
            repeatedSint64 += [try input.readSInt64()]

          case 61 :
            repeatedFixed32 += [try input.readFixed32()]

          case 65 :
            repeatedFixed64 += [try input.readFixed64()]

          case 77 :
            repeatedSfixed32 += [try input.readSFixed32()]

          case 81 :
            repeatedSfixed64 += [try input.readSFixed64()]

          case 93 :
            repeatedFloat += [try input.readFloat()]

          case 97 :
            repeatedDouble += [try input.readDouble()]

          case 104 :
            repeatedBool += [try input.readBool()]

          case 112 :
            let valueIntrepeatedNestedEnum = try input.readEnum()
            if let enumsrepeatedNestedEnum = Proto3ArenaUnittest.TestAllTypes.NestedEnum(rawValue:valueIntrepeatedNestedEnum) {
                 builderResult.repeatedNestedEnum += [enumsrepeatedNestedEnum]
            } else {
                 try unknownFieldsBuilder.mergeVarintField(14, value:Int64(valueIntrepeatedNestedEnum))
            }

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        let resultDecodedBuilder = Proto3ArenaUnittest.TestUnpackedTypes.Builder()
        if let jsonValueRepeatedInt32 = jsonMap["repeatedInt32"] as? Array<NSNumber> {
          var jsonArrayRepeatedInt32:Array<Int32> = []
          for oneValueRepeatedInt32 in jsonValueRepeatedInt32 {
            jsonArrayRepeatedInt32 += [oneValueRepeatedInt32.intValue]
          }
          resultDecodedBuilder.repeatedInt32 = jsonArrayRepeatedInt32
        }
        if let jsonValueRepeatedInt64 = jsonMap["repeatedInt64"] as? Array<String> {
          var jsonArrayRepeatedInt64:Array<Int64> = []
          for oneValueRepeatedInt64 in jsonValueRepeatedInt64 {
            jsonArrayRepeatedInt64 += [Int64(oneValueRepeatedInt64)!]
          }
          resultDecodedBuilder.repeatedInt64 = jsonArrayRepeatedInt64
        }
        if let jsonValueRepeatedUint32 = jsonMap["repeatedUint32"] as? Array<NSNumber> {
          var jsonArrayRepeatedUint32:Array<UInt32> = []
          for oneValueRepeatedUint32 in jsonValueRepeatedUint32 {
            jsonArrayRepeatedUint32 += [oneValueRepeatedUint32.unsignedIntValue]
          }
          resultDecodedBuilder.repeatedUint32 = jsonArrayRepeatedUint32
        }
        if let jsonValueRepeatedUint64 = jsonMap["repeatedUint64"] as? Array<String> {
          var jsonArrayRepeatedUint64:Array<UInt64> = []
          for oneValueRepeatedUint64 in jsonValueRepeatedUint64 {
            jsonArrayRepeatedUint64 += [UInt64(oneValueRepeatedUint64)!]
          }
          resultDecodedBuilder.repeatedUint64 = jsonArrayRepeatedUint64
        }
        if let jsonValueRepeatedSint32 = jsonMap["repeatedSint32"] as? Array<NSNumber> {
          var jsonArrayRepeatedSint32:Array<Int32> = []
          for oneValueRepeatedSint32 in jsonValueRepeatedSint32 {
            jsonArrayRepeatedSint32 += [oneValueRepeatedSint32.intValue]
          }
          resultDecodedBuilder.repeatedSint32 = jsonArrayRepeatedSint32
        }
        if let jsonValueRepeatedSint64 = jsonMap["repeatedSint64"] as? Array<String> {
          var jsonArrayRepeatedSint64:Array<Int64> = []
          for oneValueRepeatedSint64 in jsonValueRepeatedSint64 {
            jsonArrayRepeatedSint64 += [Int64(oneValueRepeatedSint64)!]
          }
          resultDecodedBuilder.repeatedSint64 = jsonArrayRepeatedSint64
        }
        if let jsonValueRepeatedFixed32 = jsonMap["repeatedFixed32"] as? Array<NSNumber> {
          var jsonArrayRepeatedFixed32:Array<UInt32> = []
          for oneValueRepeatedFixed32 in jsonValueRepeatedFixed32 {
            jsonArrayRepeatedFixed32 += [oneValueRepeatedFixed32.unsignedIntValue]
          }
          resultDecodedBuilder.repeatedFixed32 = jsonArrayRepeatedFixed32
        }
        if let jsonValueRepeatedFixed64 = jsonMap["repeatedFixed64"] as? Array<String> {
          var jsonArrayRepeatedFixed64:Array<UInt64> = []
          for oneValueRepeatedFixed64 in jsonValueRepeatedFixed64 {
            jsonArrayRepeatedFixed64 += [UInt64(oneValueRepeatedFixed64)!]
          }
          resultDecodedBuilder.repeatedFixed64 = jsonArrayRepeatedFixed64
        }
        if let jsonValueRepeatedSfixed32 = jsonMap["repeatedSfixed32"] as? Array<NSNumber> {
          var jsonArrayRepeatedSfixed32:Array<Int32> = []
          for oneValueRepeatedSfixed32 in jsonValueRepeatedSfixed32 {
            jsonArrayRepeatedSfixed32 += [oneValueRepeatedSfixed32.intValue]
          }
          resultDecodedBuilder.repeatedSfixed32 = jsonArrayRepeatedSfixed32
        }
        if let jsonValueRepeatedSfixed64 = jsonMap["repeatedSfixed64"] as? Array<String> {
          var jsonArrayRepeatedSfixed64:Array<Int64> = []
          for oneValueRepeatedSfixed64 in jsonValueRepeatedSfixed64 {
            jsonArrayRepeatedSfixed64 += [Int64(oneValueRepeatedSfixed64)!]
          }
          resultDecodedBuilder.repeatedSfixed64 = jsonArrayRepeatedSfixed64
        }
        if let jsonValueRepeatedFloat = jsonMap["repeatedFloat"] as? Array<NSNumber> {
          var jsonArrayRepeatedFloat:Array<Float> = []
          for oneValueRepeatedFloat in jsonValueRepeatedFloat {
            jsonArrayRepeatedFloat += [oneValueRepeatedFloat.floatValue]
          }
          resultDecodedBuilder.repeatedFloat = jsonArrayRepeatedFloat
        }
        if let jsonValueRepeatedDouble = jsonMap["repeatedDouble"] as? Array<NSNumber> {
          var jsonArrayRepeatedDouble:Array<Double> = []
          for oneValueRepeatedDouble in jsonValueRepeatedDouble {
            jsonArrayRepeatedDouble += [oneValueRepeatedDouble.doubleValue]
          }
          resultDecodedBuilder.repeatedDouble = jsonArrayRepeatedDouble
        }
        if let jsonValueRepeatedBool = jsonMap["repeatedBool"] as? Array<Bool> {
          resultDecodedBuilder.repeatedBool = jsonValueRepeatedBool
        }
        if let jsonValueRepeatedNestedEnum = jsonMap["repeatedNestedEnum"] as? Array<String> {
          var jsonArrayRepeatedNestedEnum:Array<Proto3ArenaUnittest.TestAllTypes.NestedEnum> = []
          for oneValueRepeatedNestedEnum in jsonValueRepeatedNestedEnum {
            let enumFromStringRepeatedNestedEnum = try Proto3ArenaUnittest.TestAllTypes.NestedEnum.fromString(oneValueRepeatedNestedEnum)
            jsonArrayRepeatedNestedEnum += [enumFromStringRepeatedNestedEnum]
          }
          resultDecodedBuilder.repeatedNestedEnum = jsonArrayRepeatedNestedEnum
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Proto3ArenaUnittest.TestUnpackedTypes.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Proto3ArenaUnittest.TestUnpackedTypes.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // This proto includes a recusively nested message.
  final public class NestedTestAllTypes : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasChild:Bool = false
    public private(set) var child:Proto3ArenaUnittest.NestedTestAllTypes!
    public private(set) var hasPayload:Bool = false
    public private(set) var payload:Proto3ArenaUnittest.TestAllTypes!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasChild {
        try output.writeMessage(1, value:child)
      }
      if hasPayload {
        try output.writeMessage(2, value:payload)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasChild {
          if let varSizechild = child?.computeMessageSize(1) {
              serialize_size += varSizechild
          }
      }
      if hasPayload {
          if let varSizepayload = payload?.computeMessageSize(2) {
              serialize_size += varSizepayload
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Proto3ArenaUnittest.NestedTestAllTypes> {
      var mergedArray = Array<Proto3ArenaUnittest.NestedTestAllTypes>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.NestedTestAllTypes? {
      return try Proto3ArenaUnittest.NestedTestAllTypes.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Proto3ArenaUnittest.NestedTestAllTypes {
      return try Proto3ArenaUnittest.NestedTestAllTypes.Builder().mergeFromData(data, extensionRegistry:Proto3ArenaUnittest.UnittestProto3ArenaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.NestedTestAllTypes {
      return try Proto3ArenaUnittest.NestedTestAllTypes.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.NestedTestAllTypes {
      return try Proto3ArenaUnittest.NestedTestAllTypes.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.NestedTestAllTypes {
      return try Proto3ArenaUnittest.NestedTestAllTypes.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.NestedTestAllTypes {
      return try Proto3ArenaUnittest.NestedTestAllTypes.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.NestedTestAllTypes {
      return try Proto3ArenaUnittest.NestedTestAllTypes.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
      return Proto3ArenaUnittest.NestedTestAllTypes.classBuilder() as! Proto3ArenaUnittest.NestedTestAllTypes.Builder
    }
    public func getBuilder() -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
      return classBuilder() as! Proto3ArenaUnittest.NestedTestAllTypes.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Proto3ArenaUnittest.NestedTestAllTypes.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Proto3ArenaUnittest.NestedTestAllTypes.Builder()
    }
    public func toBuilder() throws -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
      return try Proto3ArenaUnittest.NestedTestAllTypes.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Proto3ArenaUnittest.NestedTestAllTypes) throws -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
      return try Proto3ArenaUnittest.NestedTestAllTypes.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasChild {
        jsonMap["child"] = try child.encode()
      }
      if hasPayload {
        jsonMap["payload"] = try payload.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.NestedTestAllTypes {
      return try Proto3ArenaUnittest.NestedTestAllTypes.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Proto3ArenaUnittest.NestedTestAllTypes {
      return try Proto3ArenaUnittest.NestedTestAllTypes.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasChild {
        output += "\(indent) child {\n"
        if let outDescChild = child {
          output += try outDescChild.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasPayload {
        output += "\(indent) payload {\n"
        if let outDescPayload = payload {
          output += try outDescPayload.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasChild {
                if let hashValuechild = child?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuechild
                }
            }
            if hasPayload {
                if let hashValuepayload = payload?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepayload
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Proto3ArenaUnittest.NestedTestAllTypes"
    }
    override public func className() -> String {
        return "Proto3ArenaUnittest.NestedTestAllTypes"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Proto3ArenaUnittest.NestedTestAllTypes.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Proto3ArenaUnittest.NestedTestAllTypes = Proto3ArenaUnittest.NestedTestAllTypes()
      public func getMessage() -> Proto3ArenaUnittest.NestedTestAllTypes {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasChild:Bool {
           get {
               return builderResult.hasChild
           }
      }
      public var child:Proto3ArenaUnittest.NestedTestAllTypes! {
           get {
               if childBuilder_ != nil {
                  builderResult.child = childBuilder_.getMessage()
               }
               return builderResult.child
           }
           set (value) {
               builderResult.hasChild = true
               builderResult.child = value
           }
      }
      private var childBuilder_:Proto3ArenaUnittest.NestedTestAllTypes.Builder! {
           didSet {
              builderResult.hasChild = true
           }
      }
      public func getChildBuilder() -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        if childBuilder_ == nil {
           childBuilder_ = Proto3ArenaUnittest.NestedTestAllTypes.Builder()
           builderResult.child = childBuilder_.getMessage()
           if child != nil {
              try! childBuilder_.mergeFrom(child)
           }
        }
        return childBuilder_
      }
      public func setChild(value:Proto3ArenaUnittest.NestedTestAllTypes!) -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        self.child = value
        return self
      }
      public func mergeChild(value:Proto3ArenaUnittest.NestedTestAllTypes) throws -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        if builderResult.hasChild {
          builderResult.child = try Proto3ArenaUnittest.NestedTestAllTypes.builderWithPrototype(builderResult.child).mergeFrom(value).buildPartial()
        } else {
          builderResult.child = value
        }
        builderResult.hasChild = true
        return self
      }
      public func clearChild() -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        childBuilder_ = nil
        builderResult.hasChild = false
        builderResult.child = nil
        return self
      }
      public var hasPayload:Bool {
           get {
               return builderResult.hasPayload
           }
      }
      public var payload:Proto3ArenaUnittest.TestAllTypes! {
           get {
               if payloadBuilder_ != nil {
                  builderResult.payload = payloadBuilder_.getMessage()
               }
               return builderResult.payload
           }
           set (value) {
               builderResult.hasPayload = true
               builderResult.payload = value
           }
      }
      private var payloadBuilder_:Proto3ArenaUnittest.TestAllTypes.Builder! {
           didSet {
              builderResult.hasPayload = true
           }
      }
      public func getPayloadBuilder() -> Proto3ArenaUnittest.TestAllTypes.Builder {
        if payloadBuilder_ == nil {
           payloadBuilder_ = Proto3ArenaUnittest.TestAllTypes.Builder()
           builderResult.payload = payloadBuilder_.getMessage()
           if payload != nil {
              try! payloadBuilder_.mergeFrom(payload)
           }
        }
        return payloadBuilder_
      }
      public func setPayload(value:Proto3ArenaUnittest.TestAllTypes!) -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        self.payload = value
        return self
      }
      public func mergePayload(value:Proto3ArenaUnittest.TestAllTypes) throws -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        if builderResult.hasPayload {
          builderResult.payload = try Proto3ArenaUnittest.TestAllTypes.builderWithPrototype(builderResult.payload).mergeFrom(value).buildPartial()
        } else {
          builderResult.payload = value
        }
        builderResult.hasPayload = true
        return self
      }
      public func clearPayload() -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        payloadBuilder_ = nil
        builderResult.hasPayload = false
        builderResult.payload = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        builderResult = Proto3ArenaUnittest.NestedTestAllTypes()
        return self
      }
      override public func clone() throws -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        return try Proto3ArenaUnittest.NestedTestAllTypes.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Proto3ArenaUnittest.NestedTestAllTypes {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Proto3ArenaUnittest.NestedTestAllTypes {
        let returnMe:Proto3ArenaUnittest.NestedTestAllTypes = builderResult
        return returnMe
      }
      public func mergeFrom(other:Proto3ArenaUnittest.NestedTestAllTypes) throws -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        if other == Proto3ArenaUnittest.NestedTestAllTypes() {
         return self
        }
        if (other.hasChild) {
            try mergeChild(other.child)
        }
        if (other.hasPayload) {
            try mergePayload(other.payload)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            let subBuilder:Proto3ArenaUnittest.NestedTestAllTypes.Builder = Proto3ArenaUnittest.NestedTestAllTypes.Builder()
            if hasChild {
              try subBuilder.mergeFrom(child)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            child = subBuilder.buildPartial()

          case 18 :
            let subBuilder:Proto3ArenaUnittest.TestAllTypes.Builder = Proto3ArenaUnittest.TestAllTypes.Builder()
            if hasPayload {
              try subBuilder.mergeFrom(payload)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            payload = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        let resultDecodedBuilder = Proto3ArenaUnittest.NestedTestAllTypes.Builder()
        if let jsonValueChild = jsonMap["child"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.child = try Proto3ArenaUnittest.NestedTestAllTypes.Builder.decodeToBuilder(jsonValueChild).build()

        }
        if let jsonValuePayload = jsonMap["payload"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.payload = try Proto3ArenaUnittest.TestAllTypes.Builder.decodeToBuilder(jsonValuePayload).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Proto3ArenaUnittest.NestedTestAllTypes.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Proto3ArenaUnittest.NestedTestAllTypes.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // Define these after TestAllTypes to make sure the compiler can handle
  // that.
  final public class ForeignMessage : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasC:Bool = false
    public private(set) var c:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasC {
        try output.writeInt32(1, value:c)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasC {
        serialize_size += c.computeInt32Size(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Proto3ArenaUnittest.ForeignMessage> {
      var mergedArray = Array<Proto3ArenaUnittest.ForeignMessage>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.ForeignMessage? {
      return try Proto3ArenaUnittest.ForeignMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Proto3ArenaUnittest.ForeignMessage {
      return try Proto3ArenaUnittest.ForeignMessage.Builder().mergeFromData(data, extensionRegistry:Proto3ArenaUnittest.UnittestProto3ArenaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.ForeignMessage {
      return try Proto3ArenaUnittest.ForeignMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.ForeignMessage {
      return try Proto3ArenaUnittest.ForeignMessage.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.ForeignMessage {
      return try Proto3ArenaUnittest.ForeignMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.ForeignMessage {
      return try Proto3ArenaUnittest.ForeignMessage.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.ForeignMessage {
      return try Proto3ArenaUnittest.ForeignMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Proto3ArenaUnittest.ForeignMessage.Builder {
      return Proto3ArenaUnittest.ForeignMessage.classBuilder() as! Proto3ArenaUnittest.ForeignMessage.Builder
    }
    public func getBuilder() -> Proto3ArenaUnittest.ForeignMessage.Builder {
      return classBuilder() as! Proto3ArenaUnittest.ForeignMessage.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Proto3ArenaUnittest.ForeignMessage.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Proto3ArenaUnittest.ForeignMessage.Builder()
    }
    public func toBuilder() throws -> Proto3ArenaUnittest.ForeignMessage.Builder {
      return try Proto3ArenaUnittest.ForeignMessage.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Proto3ArenaUnittest.ForeignMessage) throws -> Proto3ArenaUnittest.ForeignMessage.Builder {
      return try Proto3ArenaUnittest.ForeignMessage.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasC {
        jsonMap["c"] = NSNumber(int:c)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.ForeignMessage {
      return try Proto3ArenaUnittest.ForeignMessage.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Proto3ArenaUnittest.ForeignMessage {
      return try Proto3ArenaUnittest.ForeignMessage.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasC {
        output += "\(indent) c: \(c) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasC {
               hashCode = (hashCode &* 31) &+ c.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Proto3ArenaUnittest.ForeignMessage"
    }
    override public func className() -> String {
        return "Proto3ArenaUnittest.ForeignMessage"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Proto3ArenaUnittest.ForeignMessage.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Proto3ArenaUnittest.ForeignMessage = Proto3ArenaUnittest.ForeignMessage()
      public func getMessage() -> Proto3ArenaUnittest.ForeignMessage {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasC:Bool {
           get {
                return builderResult.hasC
           }
      }
      public var c:Int32 {
           get {
                return builderResult.c
           }
           set (value) {
               builderResult.hasC = true
               builderResult.c = value
           }
      }
      public func setC(value:Int32) -> Proto3ArenaUnittest.ForeignMessage.Builder {
        self.c = value
        return self
      }
      public func clearC() -> Proto3ArenaUnittest.ForeignMessage.Builder{
           builderResult.hasC = false
           builderResult.c = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Proto3ArenaUnittest.ForeignMessage.Builder {
        builderResult = Proto3ArenaUnittest.ForeignMessage()
        return self
      }
      override public func clone() throws -> Proto3ArenaUnittest.ForeignMessage.Builder {
        return try Proto3ArenaUnittest.ForeignMessage.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Proto3ArenaUnittest.ForeignMessage {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Proto3ArenaUnittest.ForeignMessage {
        let returnMe:Proto3ArenaUnittest.ForeignMessage = builderResult
        return returnMe
      }
      public func mergeFrom(other:Proto3ArenaUnittest.ForeignMessage) throws -> Proto3ArenaUnittest.ForeignMessage.Builder {
        if other == Proto3ArenaUnittest.ForeignMessage() {
         return self
        }
        if other.hasC {
             c = other.c
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.ForeignMessage.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.ForeignMessage.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            c = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.ForeignMessage.Builder {
        let resultDecodedBuilder = Proto3ArenaUnittest.ForeignMessage.Builder()
        if let jsonValueC = jsonMap["c"] as? NSNumber {
          resultDecodedBuilder.c = jsonValueC.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Proto3ArenaUnittest.ForeignMessage.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Proto3ArenaUnittest.ForeignMessage.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  // TestEmptyMessage is used to test behavior of unknown fields.
  final public class TestEmptyMessage : GeneratedMessage, GeneratedMessageProtocol {
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Proto3ArenaUnittest.TestEmptyMessage> {
      var mergedArray = Array<Proto3ArenaUnittest.TestEmptyMessage>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.TestEmptyMessage? {
      return try Proto3ArenaUnittest.TestEmptyMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Proto3ArenaUnittest.TestEmptyMessage {
      return try Proto3ArenaUnittest.TestEmptyMessage.Builder().mergeFromData(data, extensionRegistry:Proto3ArenaUnittest.UnittestProto3ArenaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestEmptyMessage {
      return try Proto3ArenaUnittest.TestEmptyMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Proto3ArenaUnittest.TestEmptyMessage {
      return try Proto3ArenaUnittest.TestEmptyMessage.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestEmptyMessage {
      return try Proto3ArenaUnittest.TestEmptyMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.TestEmptyMessage {
      return try Proto3ArenaUnittest.TestEmptyMessage.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestEmptyMessage {
      return try Proto3ArenaUnittest.TestEmptyMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Proto3ArenaUnittest.TestEmptyMessage.Builder {
      return Proto3ArenaUnittest.TestEmptyMessage.classBuilder() as! Proto3ArenaUnittest.TestEmptyMessage.Builder
    }
    public func getBuilder() -> Proto3ArenaUnittest.TestEmptyMessage.Builder {
      return classBuilder() as! Proto3ArenaUnittest.TestEmptyMessage.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Proto3ArenaUnittest.TestEmptyMessage.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Proto3ArenaUnittest.TestEmptyMessage.Builder()
    }
    public func toBuilder() throws -> Proto3ArenaUnittest.TestEmptyMessage.Builder {
      return try Proto3ArenaUnittest.TestEmptyMessage.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Proto3ArenaUnittest.TestEmptyMessage) throws -> Proto3ArenaUnittest.TestEmptyMessage.Builder {
      return try Proto3ArenaUnittest.TestEmptyMessage.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      let jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.TestEmptyMessage {
      return try Proto3ArenaUnittest.TestEmptyMessage.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Proto3ArenaUnittest.TestEmptyMessage {
      return try Proto3ArenaUnittest.TestEmptyMessage.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Proto3ArenaUnittest.TestEmptyMessage"
    }
    override public func className() -> String {
        return "Proto3ArenaUnittest.TestEmptyMessage"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Proto3ArenaUnittest.TestEmptyMessage.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Proto3ArenaUnittest.TestEmptyMessage = Proto3ArenaUnittest.TestEmptyMessage()
      public func getMessage() -> Proto3ArenaUnittest.TestEmptyMessage {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Proto3ArenaUnittest.TestEmptyMessage.Builder {
        builderResult = Proto3ArenaUnittest.TestEmptyMessage()
        return self
      }
      override public func clone() throws -> Proto3ArenaUnittest.TestEmptyMessage.Builder {
        return try Proto3ArenaUnittest.TestEmptyMessage.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Proto3ArenaUnittest.TestEmptyMessage {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Proto3ArenaUnittest.TestEmptyMessage {
        let returnMe:Proto3ArenaUnittest.TestEmptyMessage = builderResult
        return returnMe
      }
      public func mergeFrom(other:Proto3ArenaUnittest.TestEmptyMessage) throws -> Proto3ArenaUnittest.TestEmptyMessage.Builder {
        if other == Proto3ArenaUnittest.TestEmptyMessage() {
         return self
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Proto3ArenaUnittest.TestEmptyMessage.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Proto3ArenaUnittest.TestEmptyMessage.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Proto3ArenaUnittest.TestEmptyMessage.Builder {
        let resultDecodedBuilder = Proto3ArenaUnittest.TestEmptyMessage.Builder()
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Proto3ArenaUnittest.TestEmptyMessage.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Proto3ArenaUnittest.TestEmptyMessage.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)

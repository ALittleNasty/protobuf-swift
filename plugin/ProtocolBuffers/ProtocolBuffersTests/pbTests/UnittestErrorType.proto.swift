// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "unittest_error_type.proto"
// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public func == (lhs: UserProfile, rhs: UserProfile) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFirstName == rhs.hasFirstName) && (!lhs.hasFirstName || lhs.firstName == rhs.firstName)
  fieldCheck = fieldCheck && (lhs.hasLastName == rhs.hasLastName) && (!lhs.hasLastName || lhs.lastName == rhs.lastName)
  fieldCheck = fieldCheck && (lhs.hasAvatarUrl == rhs.hasAvatarUrl) && (!lhs.hasAvatarUrl || lhs.avatarUrl == rhs.avatarUrl)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: UserProfile.Request, rhs: UserProfile.Request) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: UserProfile.Response, rhs: UserProfile.Response) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasProfile == rhs.hasProfile) && (!lhs.hasProfile || lhs.profile == rhs.profile)
  fieldCheck = fieldCheck && (lhs.hasError == rhs.hasError) && (!lhs.hasError || lhs.error == rhs.error)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct UnittestErrorTypeRoot {
  public static var sharedInstance : UnittestErrorTypeRoot {
   struct Static {
       static let instance : UnittestErrorTypeRoot = UnittestErrorTypeRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(registry: extensionRegistry)
    Google.Protobuf.SwiftDescriptorRoot.sharedInstance.registerAllExtensions(registry: extensionRegistry)
  }
  public func registerAllExtensions(registry: ExtensionRegistry) {
  }
}



//Enum type declaration start 

public enum ServiceError:Error, RawRepresentable, CustomDebugStringConvertible, CustomStringConvertible {
  public typealias RawValue = Int32

  case badRequest
  case internalServerError

  public init?(rawValue: RawValue) {
    switch rawValue {
    case 0: self = .badRequest
    case 1: self = .internalServerError
    default: return nil
    }
  }

  public var rawValue: RawValue {
    switch self {
    case .badRequest: return 0
    case .internalServerError: return 1
    }
  }
  public func toString() -> String {
    switch self {
    case .badRequest: return "BadRequest"
    case .internalServerError: return "InternalServerError"
    }
  }
  public static func fromString(str:String) throws -> ServiceError {
    switch str {
    case "BadRequest":  return .badRequest
    case "InternalServerError":  return .internalServerError
    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
    }
  }
  public var debugDescription:String { return getDescription() }
  public var description:String { return getDescription() }
  private func getDescription() -> String { 
      switch self {
          case .badRequest: return ".badRequest"
          case .internalServerError: return ".internalServerError"
      }
  }
}

//Enum type declaration end 

final public class UserProfile : GeneratedMessage {


  //Nested type declaration start

    final public class Request : GeneratedMessage {
      public private(set) var userId:String = ""
      public private(set) var hasUserId:Bool = false

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasUserId {
          return false
        }
       return true
      }
      override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasUserId {
          try codedOutputStream.writeString(fieldNumber: 1, value:userId)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUserId {
          serialize_size += userId.computeStringSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func getBuilder() -> UserProfile.Request.Builder {
        return UserProfile.Request.classBuilder() as! UserProfile.Request.Builder
      }
      public func getBuilder() -> UserProfile.Request.Builder {
        return classBuilder() as! UserProfile.Request.Builder
      }
      override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UserProfile.Request.Builder()
      }
      override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UserProfile.Request.Builder()
      }
      public func toBuilder() throws -> UserProfile.Request.Builder {
        return try UserProfile.Request.builderWithPrototype(prototype:self)
      }
      public class func builderWithPrototype(prototype:UserProfile.Request) throws -> UserProfile.Request.Builder {
        return try UserProfile.Request.Builder().mergeFrom(other:prototype)
      }
      override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasUserId {
          jsonMap["userId"] = userId
        }
        return jsonMap
      }
      override class public func decode(jsonMap:Dictionary<String,Any>) throws -> UserProfile.Request {
        return try UserProfile.Request.Builder.decodeToBuilder(jsonMap:jsonMap).build()
      }
      override class public func fromJSON(data:Data) throws -> UserProfile.Request {
        return try UserProfile.Request.Builder.fromJSONToBuilder(data:data).build()
      }
      override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasUserId {
          output += "\(indent) userId: \(userId) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasUserId {
                 hashCode = (hashCode &* 31) &+ userId.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "UserProfile.Request"
      }
      override public func className() -> String {
          return "UserProfile.Request"
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:UserProfile.Request = UserProfile.Request()
        public func getMessage() -> UserProfile.Request {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasUserId:Bool {
             get {
                  return builderResult.hasUserId
             }
        }
        public var userId:String {
             get {
                  return builderResult.userId
             }
             set (value) {
                 builderResult.hasUserId = true
                 builderResult.userId = value
             }
        }
        public func setUserId(_ value:String) -> UserProfile.Request.Builder {
          self.userId = value
          return self
        }
        public func clearUserId() -> UserProfile.Request.Builder{
             builderResult.hasUserId = false
             builderResult.userId = ""
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        override public func clear() -> UserProfile.Request.Builder {
          builderResult = UserProfile.Request()
          return self
        }
        override public func clone() throws -> UserProfile.Request.Builder {
          return try UserProfile.Request.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> UserProfile.Request {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> UserProfile.Request {
          let returnMe:UserProfile.Request = builderResult
          return returnMe
        }
        public func mergeFrom(other:UserProfile.Request) throws -> UserProfile.Request.Builder {
          if other == UserProfile.Request() {
           return self
          }
          if other.hasUserId {
               userId = other.userId
          }
          _ = try merge(unknownField: other.unknownFields)
          return self
        }
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> UserProfile.Request.Builder {
             return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Request.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
          while (true) {
            let protobufTag = try codedInputStream.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10:
              userId = try codedInputStream.readString()

            default:
              if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
        class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> UserProfile.Request.Builder {
          let resultDecodedBuilder = UserProfile.Request.Builder()
          if let jsonValueUserId = jsonMap["userId"] as? String {
            resultDecodedBuilder.userId = jsonValueUserId
          }
          return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> UserProfile.Request.Builder {
          let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
          guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
          }
          return try UserProfile.Request.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class Response : GeneratedMessage {
      public private(set) var profile:UserProfile!
      public private(set) var hasProfile:Bool = false
      public private(set) var error:ServiceError = ServiceError.badRequest
      public private(set) var hasError:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasProfile {
          try codedOutputStream.writeMessage(fieldNumber: 1, value:profile)
        }
        if hasError {
          try codedOutputStream.writeEnum(fieldNumber: 2, value:error.rawValue)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasProfile {
            if let varSizeprofile = profile?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizeprofile
            }
        }
        if (hasError) {
          serialize_size += error.rawValue.computeEnumSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func getBuilder() -> UserProfile.Response.Builder {
        return UserProfile.Response.classBuilder() as! UserProfile.Response.Builder
      }
      public func getBuilder() -> UserProfile.Response.Builder {
        return classBuilder() as! UserProfile.Response.Builder
      }
      override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UserProfile.Response.Builder()
      }
      override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return UserProfile.Response.Builder()
      }
      public func toBuilder() throws -> UserProfile.Response.Builder {
        return try UserProfile.Response.builderWithPrototype(prototype:self)
      }
      public class func builderWithPrototype(prototype:UserProfile.Response) throws -> UserProfile.Response.Builder {
        return try UserProfile.Response.Builder().mergeFrom(other:prototype)
      }
      override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasProfile {
          jsonMap["profile"] = try profile.encode()
        }
        if hasError {
          jsonMap["error"] = error.toString()
        }
        return jsonMap
      }
      override class public func decode(jsonMap:Dictionary<String,Any>) throws -> UserProfile.Response {
        return try UserProfile.Response.Builder.decodeToBuilder(jsonMap:jsonMap).build()
      }
      override class public func fromJSON(data:Data) throws -> UserProfile.Response {
        return try UserProfile.Response.Builder.fromJSONToBuilder(data:data).build()
      }
      override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasProfile {
          output += "\(indent) profile {\n"
          if let outDescProfile = profile {
            output += try outDescProfile.getDescription(indent: "\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if (hasError) {
          output += "\(indent) error: \(error.description)\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasProfile {
                  if let hashValueprofile = profile?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueprofile
                  }
              }
              if hasError {
                 hashCode = (hashCode &* 31) &+ Int(error.rawValue)
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "UserProfile.Response"
      }
      override public func className() -> String {
          return "UserProfile.Response"
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:UserProfile.Response = UserProfile.Response()
        public func getMessage() -> UserProfile.Response {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasProfile:Bool {
             get {
                 return builderResult.hasProfile
             }
        }
        public var profile:UserProfile! {
             get {
                 if profileBuilder_ != nil {
                    builderResult.profile = profileBuilder_.getMessage()
                 }
                 return builderResult.profile
             }
             set (value) {
                 builderResult.hasProfile = true
                 builderResult.profile = value
             }
        }
        private var profileBuilder_:UserProfile.Builder! {
             didSet {
                builderResult.hasProfile = true
             }
        }
        public func getProfileBuilder() -> UserProfile.Builder {
          if profileBuilder_ == nil {
             profileBuilder_ = UserProfile.Builder()
             builderResult.profile = profileBuilder_.getMessage()
             if profile != nil {
                _ = try! profileBuilder_.mergeFrom(other: profile)
             }
          }
          return profileBuilder_
        }
        public func setProfile(_ value:UserProfile!) -> UserProfile.Response.Builder {
          self.profile = value
          return self
        }
        public func mergeProfile(value:UserProfile) throws -> UserProfile.Response.Builder {
          if builderResult.hasProfile {
            builderResult.profile = try UserProfile.builderWithPrototype(prototype:builderResult.profile).mergeFrom(other: value).buildPartial()
          } else {
            builderResult.profile = value
          }
          builderResult.hasProfile = true
          return self
        }
        public func clearProfile() -> UserProfile.Response.Builder {
          profileBuilder_ = nil
          builderResult.hasProfile = false
          builderResult.profile = nil
          return self
        }
          public var hasError:Bool{
              get {
                  return builderResult.hasError
              }
          }
          public var error:ServiceError {
              get {
                  return builderResult.error
              }
              set (value) {
                  builderResult.hasError = true
                  builderResult.error = value
              }
          }
          public func setError(_ value:ServiceError) -> UserProfile.Response.Builder {
            self.error = value
            return self
          }
          public func clearError() -> UserProfile.Response.Builder {
             builderResult.hasError = false
             builderResult.error = .badRequest
             return self
          }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        override public func clear() -> UserProfile.Response.Builder {
          builderResult = UserProfile.Response()
          return self
        }
        override public func clone() throws -> UserProfile.Response.Builder {
          return try UserProfile.Response.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> UserProfile.Response {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> UserProfile.Response {
          let returnMe:UserProfile.Response = builderResult
          return returnMe
        }
        public func mergeFrom(other:UserProfile.Response) throws -> UserProfile.Response.Builder {
          if other == UserProfile.Response() {
           return self
          }
          if (other.hasProfile) {
              _ = try mergeProfile(value: other.profile)
          }
          if other.hasError {
               error = other.error
          }
          _ = try merge(unknownField: other.unknownFields)
          return self
        }
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> UserProfile.Response.Builder {
             return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Response.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
          while (true) {
            let protobufTag = try codedInputStream.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10:
              let subBuilder:UserProfile.Builder = UserProfile.Builder()
              if hasProfile {
                _ = try subBuilder.mergeFrom(other: profile)
              }
              try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
              profile = subBuilder.buildPartial()

            case 16:
              let valueInterror = try codedInputStream.readEnum()
              if let enumserror = ServiceError(rawValue:valueInterror){
                   error = enumserror
              } else {
                   _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueInterror))
              }

            default:
              if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
        class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> UserProfile.Response.Builder {
          let resultDecodedBuilder = UserProfile.Response.Builder()
          if let jsonValueProfile = jsonMap["profile"] as? Dictionary<String,Any> {
            resultDecodedBuilder.profile = try UserProfile.Builder.decodeToBuilder(jsonMap:jsonValueProfile).build()

          }
          if let jsonValueError = jsonMap["error"] as? String {
            resultDecodedBuilder.error = try ServiceError.fromString(str: jsonValueError)
          }
          return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> UserProfile.Response.Builder {
          let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
          guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
          }
          return try UserProfile.Response.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
      }

    }

  //Nested type declaration end

  public private(set) var firstName:String = ""
  public private(set) var hasFirstName:Bool = false

  public private(set) var lastName:String = ""
  public private(set) var hasLastName:Bool = false

  public private(set) var avatarUrl:String = ""
  public private(set) var hasAvatarUrl:Bool = false

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream: CodedOutputStream) throws {
    if hasFirstName {
      try codedOutputStream.writeString(fieldNumber: 1, value:firstName)
    }
    if hasLastName {
      try codedOutputStream.writeString(fieldNumber: 2, value:lastName)
    }
    if hasAvatarUrl {
      try codedOutputStream.writeString(fieldNumber: 3, value:avatarUrl)
    }
    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasFirstName {
      serialize_size += firstName.computeStringSize(fieldNumber: 1)
    }
    if hasLastName {
      serialize_size += lastName.computeStringSize(fieldNumber: 2)
    }
    if hasAvatarUrl {
      serialize_size += avatarUrl.computeStringSize(fieldNumber: 3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> UserProfile.Builder {
    return UserProfile.classBuilder() as! UserProfile.Builder
  }
  public func getBuilder() -> UserProfile.Builder {
    return classBuilder() as! UserProfile.Builder
  }
  override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return UserProfile.Builder()
  }
  override public func classBuilder() -> ProtocolBuffersMessageBuilder {
    return UserProfile.Builder()
  }
  public func toBuilder() throws -> UserProfile.Builder {
    return try UserProfile.builderWithPrototype(prototype:self)
  }
  public class func builderWithPrototype(prototype:UserProfile) throws -> UserProfile.Builder {
    return try UserProfile.Builder().mergeFrom(other:prototype)
  }
  override public func encode() throws -> Dictionary<String,Any> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
    if hasFirstName {
      jsonMap["firstName"] = firstName
    }
    if hasLastName {
      jsonMap["lastName"] = lastName
    }
    if hasAvatarUrl {
      jsonMap["avatarUrl"] = avatarUrl
    }
    return jsonMap
  }
  override class public func decode(jsonMap:Dictionary<String,Any>) throws -> UserProfile {
    return try UserProfile.Builder.decodeToBuilder(jsonMap:jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> UserProfile {
    return try UserProfile.Builder.fromJSONToBuilder(data:data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasFirstName {
      output += "\(indent) firstName: \(firstName) \n"
    }
    if hasLastName {
      output += "\(indent) lastName: \(lastName) \n"
    }
    if hasAvatarUrl {
      output += "\(indent) avatarUrl: \(avatarUrl) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasFirstName {
             hashCode = (hashCode &* 31) &+ firstName.hashValue
          }
          if hasLastName {
             hashCode = (hashCode &* 31) &+ lastName.hashValue
          }
          if hasAvatarUrl {
             hashCode = (hashCode &* 31) &+ avatarUrl.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "UserProfile"
  }
  override public func className() -> String {
      return "UserProfile"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:UserProfile = UserProfile()
    public func getMessage() -> UserProfile {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasFirstName:Bool {
         get {
              return builderResult.hasFirstName
         }
    }
    public var firstName:String {
         get {
              return builderResult.firstName
         }
         set (value) {
             builderResult.hasFirstName = true
             builderResult.firstName = value
         }
    }
    public func setFirstName(_ value:String) -> UserProfile.Builder {
      self.firstName = value
      return self
    }
    public func clearFirstName() -> UserProfile.Builder{
         builderResult.hasFirstName = false
         builderResult.firstName = ""
         return self
    }
    public var hasLastName:Bool {
         get {
              return builderResult.hasLastName
         }
    }
    public var lastName:String {
         get {
              return builderResult.lastName
         }
         set (value) {
             builderResult.hasLastName = true
             builderResult.lastName = value
         }
    }
    public func setLastName(_ value:String) -> UserProfile.Builder {
      self.lastName = value
      return self
    }
    public func clearLastName() -> UserProfile.Builder{
         builderResult.hasLastName = false
         builderResult.lastName = ""
         return self
    }
    public var hasAvatarUrl:Bool {
         get {
              return builderResult.hasAvatarUrl
         }
    }
    public var avatarUrl:String {
         get {
              return builderResult.avatarUrl
         }
         set (value) {
             builderResult.hasAvatarUrl = true
             builderResult.avatarUrl = value
         }
    }
    public func setAvatarUrl(_ value:String) -> UserProfile.Builder {
      self.avatarUrl = value
      return self
    }
    public func clearAvatarUrl() -> UserProfile.Builder{
         builderResult.hasAvatarUrl = false
         builderResult.avatarUrl = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    override public func clear() -> UserProfile.Builder {
      builderResult = UserProfile()
      return self
    }
    override public func clone() throws -> UserProfile.Builder {
      return try UserProfile.builderWithPrototype(prototype:builderResult)
    }
    override public func build() throws -> UserProfile {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> UserProfile {
      let returnMe:UserProfile = builderResult
      return returnMe
    }
    public func mergeFrom(other:UserProfile) throws -> UserProfile.Builder {
      if other == UserProfile() {
       return self
      }
      if other.hasFirstName {
           firstName = other.firstName
      }
      if other.hasLastName {
           lastName = other.lastName
      }
      if other.hasAvatarUrl {
           avatarUrl = other.avatarUrl
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> UserProfile.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          firstName = try codedInputStream.readString()

        case 18:
          lastName = try codedInputStream.readString()

        case 26:
          avatarUrl = try codedInputStream.readString()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> UserProfile.Builder {
      let resultDecodedBuilder = UserProfile.Builder()
      if let jsonValueFirstName = jsonMap["firstName"] as? String {
        resultDecodedBuilder.firstName = jsonValueFirstName
      }
      if let jsonValueLastName = jsonMap["lastName"] as? String {
        resultDecodedBuilder.lastName = jsonValueLastName
      }
      if let jsonValueAvatarUrl = jsonMap["avatarUrl"] as? String {
        resultDecodedBuilder.avatarUrl = jsonValueAvatarUrl
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> UserProfile.Builder {
      let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try UserProfile.Builder.decodeToBuilder(jsonMap:jsDataCast)
    }
  }

}

extension UserProfile: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<UserProfile> {
    var mergedArray = Array<UserProfile>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> UserProfile? {
    return try UserProfile.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> UserProfile {
    return try UserProfile.Builder().mergeFrom(data: data, extensionRegistry:UnittestErrorTypeRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> UserProfile {
    return try UserProfile.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> UserProfile {
    return try UserProfile.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile {
    return try UserProfile.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> UserProfile {
    return try UserProfile.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile {
    return try UserProfile.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension UserProfile.Request: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<UserProfile.Request> {
    var mergedArray = Array<UserProfile.Request>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> UserProfile.Request? {
    return try UserProfile.Request.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> UserProfile.Request {
    return try UserProfile.Request.Builder().mergeFrom(data: data, extensionRegistry:UnittestErrorTypeRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Request {
    return try UserProfile.Request.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> UserProfile.Request {
    return try UserProfile.Request.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Request {
    return try UserProfile.Request.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> UserProfile.Request {
    return try UserProfile.Request.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Request {
    return try UserProfile.Request.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension UserProfile.Response: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<UserProfile.Response> {
    var mergedArray = Array<UserProfile.Response>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> UserProfile.Response? {
    return try UserProfile.Response.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> UserProfile.Response {
    return try UserProfile.Response.Builder().mergeFrom(data: data, extensionRegistry:UnittestErrorTypeRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Response {
    return try UserProfile.Response.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> UserProfile.Response {
    return try UserProfile.Response.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Response {
    return try UserProfile.Response.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> UserProfile.Response {
    return try UserProfile.Response.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserProfile.Response {
    return try UserProfile.Response.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}

// @@protoc_insertion_point(global_scope)
